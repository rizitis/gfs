From 7f21acd958c48560e1930bb0875f1da16dfad4e3 Mon Sep 17 00:00:00 2001
From: Jordan Petridis <jordan@centricular.com>
Date: Sat, 7 Oct 2023 19:36:51 +0300
Subject: [PATCH 1/2] session: Remove x11 session targets

This is the first step towards deprecating the x11 session,
the gnome-xorg.desktop file is removed along with
the gnome-session-{x11, @} systemd targets.

But the x11 functionality is still there so it can be restored
by installing the files in the appropriate place again.

X11 has been receiving less and less testing. We have been
defaulting to the wayland session since 2016 and it's about
time we drop the x11 session completely.

Let's remove the desktop file and targets this cycle and maybe
carry on with removing rest of the x11 session code next cycle.

For removing the x11 code as well, see [1]

[1]: https://gitlab.gnome.org/GNOME/gnome-session/-/merge_requests/99
---
 data/gnome-session-x11.target  | 16 ----------------
 data/gnome-session-x11@.target | 22 ----------------------
 data/gnome-xorg.desktop.in.in  |  8 --------
 data/meson.build               | 16 ++--------------
 meson_post_install.py          |  5 -----
 5 files changed, 2 insertions(+), 65 deletions(-)
 delete mode 100644 data/gnome-session-x11.target
 delete mode 100644 data/gnome-session-x11@.target
 delete mode 100644 data/gnome-xorg.desktop.in.in

diff --git a/data/gnome-session-x11.target b/data/gnome-session-x11.target
deleted file mode 100644
index e13cc9eec..000000000
--- a/data/gnome-session-x11.target
+++ /dev/null
@@ -1,16 +0,0 @@
-[Unit]
-Description=GNOME X11 Session
-# On X11, try to show the fail screen
-OnFailure=gnome-session-failed.target
-OnFailureJobMode=replace
-# Avoid default After/Before rules
-DefaultDependencies=no
-
-Before=gnome-session.target
-
-PartOf=graphical-session.target
-RefuseManualStart=yes
-RefuseManualStop=yes
-
-# Pull in all X11-specific services the session might depend on
-Requires=gnome-session-x11-services.target
diff --git a/data/gnome-session-x11@.target b/data/gnome-session-x11@.target
deleted file mode 100644
index ce5879b20..000000000
--- a/data/gnome-session-x11@.target
+++ /dev/null
@@ -1,22 +0,0 @@
-[Unit]
-Description=GNOME X11 Session (session: %i)
-OnFailure=gnome-session-failed.target
-OnFailureJobMode=replace
-DefaultDependencies=no
-# Start happens explicitly
-RefuseManualStart=no
-# Stop happens by starting gnome-session-shutdown.target
-#RefuseManualStop=yes
-
-Conflicts=shutdown.target gnome-session-shutdown.target
-PartOf=graphical-session.target
-
-# As this is the main entry point, pull in the other toplevel gnome-session targets
-BindsTo=gnome-session@.target
-After=gnome-session@.target
-
-BindsTo=gnome-session-x11.target
-After=gnome-session-x11.target
-
-BindsTo=gnome-session.target
-After=gnome-session.target
diff --git a/data/gnome-xorg.desktop.in.in b/data/gnome-xorg.desktop.in.in
deleted file mode 100644
index 9a76fac87..000000000
--- a/data/gnome-xorg.desktop.in.in
+++ /dev/null
@@ -1,8 +0,0 @@
-[Desktop Entry]
-Name=GNOME on Xorg
-Comment=This session logs you into GNOME
-Exec=@bindir@/gnome-session
-TryExec=@bindir@/gnome-session
-Type=Application
-DesktopNames=GNOME
-X-GDM-SessionRegisters=true
diff --git a/data/meson.build b/data/meson.build
index 006000e92..007c399d6 100644
--- a/data/meson.build
+++ b/data/meson.build
@@ -2,8 +2,6 @@ desktop_plain = 'gnome'
 
 desktops = [
   desktop_plain,
-  'gnome-xorg',
-  'gnome-wayland',
 ]
 
 shell_component = {
@@ -47,20 +45,10 @@ foreach name: desktops
     configuration: desktop_conf
   )
 
-  if name.endswith('-xorg')
+  if name == 'gnome-custom-session'
     install_dir = session_datadir / 'xsessions'
-  elif name.endswith('-wayland')
-    install_dir = session_datadir / 'wayland-sessions'
   else
-    # FIXME: The same target can not be copied into two directories.
-    #        There is a workaround in meson_post_install.py until proper
-    #        solution arises:
-    #        https://github.com/mesonbuild/meson/issues/2416
-    install_dir = session_datadir / 'xsessions'
-    #install_dir = [
-    #  join_paths(session_datadir, 'xsessions'),
-    #  join_paths(session_datadir, 'wayland-sessions')
-    #]
+    install_dir = session_datadir / 'wayland-sessions'
   endif
 
   desktop_target = i18n.merge_file(
diff --git a/meson_post_install.py b/meson_post_install.py
index 31502db3f..c5caba57b 100644
--- a/meson_post_install.py
+++ b/meson_post_install.py
@@ -1,7 +1,6 @@
 #!/usr/bin/env python3
 
 import os
-import shutil
 import sys
 
 if os.environ.get('DESTDIR'):
@@ -14,7 +13,3 @@ else:
 dst_dir = os.path.join(install_root, 'wayland-sessions')
 if not os.path.exists(dst_dir):
   os.makedirs(dst_dir)
-
-src = os.path.join(install_root, 'xsessions', 'gnome.desktop')
-dst = os.path.join(dst_dir, 'gnome.desktop')
-shutil.copyfile(src, dst)
-- 
GitLab


From 43c400557481ae5cd0b6cb51f8426428fcdaf911 Mon Sep 17 00:00:00 2001
From: Jordan Petridis <jordan@centricular.com>
Date: Sat, 7 Oct 2023 19:16:38 +0300
Subject: [PATCH 2/2] Remove x11 session code
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

In !98 we removed the x11 session targets, deprecating the x11 session,
Now it's time to also remove the code related to it.

Followup to https://gitlab.gnome.org/GNOME/gnome-session/-/merge_requests/98

Remove all the code related to the x11 session. Farewell ðŸª¦
---
 data/meson.build                              |  54 +-
 data/session-selector.ui                      | 195 -----
 doc/man/gnome-session-selector.xml            |  52 --
 doc/man/gnome-session.1                       |   8 +-
 doc/man/meson.build                           |   4 -
 gnome-session/gsm-autostart-app.h             |   2 -
 gnome-session/gsm-fail-whale-dialog.c         |  24 -
 gnome-session/gsm-manager.c                   | 139 ----
 gnome-session/gsm-systemd.c                   |   5 +-
 gnome-session/gsm-xsmp-server.c               | 746 ------------------
 gnome-session/gsm-xsmp-server.h               |  40 -
 gnome-session/meson.build                     |   2 -
 gnome-session/test-inhibit.c                  |   1 +
 meson.build                                   |  13 +-
 meson_options.txt                             |   1 -
 meson_post_install.py                         |  11 +
 .../gnome-session-check-accelerated-common.h  |  29 -
 ...nome-session-check-accelerated-gl-helper.c | 517 ------------
 ...me-session-check-accelerated-gles-helper.c | 201 -----
 tools/gnome-session-check-accelerated.c       | 318 --------
 tools/gnome-session-custom-session            |   4 -
 tools/gnome-session-selector.c                | 698 ----------------
 tools/meson.build                             |  50 +-
 23 files changed, 36 insertions(+), 3078 deletions(-)
 delete mode 100644 data/session-selector.ui
 delete mode 100644 doc/man/gnome-session-selector.xml
 delete mode 100644 gnome-session/gsm-xsmp-server.c
 delete mode 100644 gnome-session/gsm-xsmp-server.h
 delete mode 100644 tools/gnome-session-check-accelerated-common.h
 delete mode 100644 tools/gnome-session-check-accelerated-gl-helper.c
 delete mode 100644 tools/gnome-session-check-accelerated-gles-helper.c
 delete mode 100644 tools/gnome-session-check-accelerated.c
 delete mode 100755 tools/gnome-session-custom-session
 delete mode 100644 tools/gnome-session-selector.c

diff --git a/data/meson.build b/data/meson.build
index 007c399d6..7f8598b21 100644
--- a/data/meson.build
+++ b/data/meson.build
@@ -1,9 +1,5 @@
 desktop_plain = 'gnome'
 
-desktops = [
-  desktop_plain,
-]
-
 shell_component = {
   desktop_plain: 'org.gnome.Shell',
 }
@@ -29,37 +25,27 @@ required_components = {
   ],
 }
 
-if enable_session_selector
-  desktops += 'gnome-custom-session'
-endif
+desktop_conf = configuration_data()
+desktop_conf.set('bindir', session_bindir)
 
-foreach name: desktops
-  desktop_conf = configuration_data()
-  desktop_conf.set('bindir', session_bindir)
+desktop = desktop_plain + '.desktop'
 
-  desktop = name + '.desktop'
-
-  desktop_in = configure_file(
-    input: desktop + '.in.in',
-    output: desktop + '.in',
-    configuration: desktop_conf
-  )
+desktop_in = configure_file(
+  input: desktop + '.in.in',
+  output: desktop + '.in',
+  configuration: desktop_conf
+)
 
-  if name == 'gnome-custom-session'
-    install_dir = session_datadir / 'xsessions'
-  else
-    install_dir = session_datadir / 'wayland-sessions'
-  endif
+install_dir = session_datadir / 'wayland-sessions'
 
-  desktop_target = i18n.merge_file(
-    type: 'desktop',
-    input: desktop_in,
-    output: desktop,
-    po_dir: po_dir,
-    install: true,
-    install_dir: install_dir
-  )
-endforeach
+i18n.merge_file(
+  type: 'desktop',
+  input: desktop_in,
+  output: desktop,
+  po_dir: po_dir,
+  install: true,
+  install_dir: install_dir
+)
 
 sessions = [
   'gnome',
@@ -117,8 +103,6 @@ endforeach
 
 systemd_target = files('gnome-session-wayland@.target',
                         'gnome-session-wayland.target',
-                        'gnome-session-x11@.target',
-                        'gnome-session-x11.target',
                         'gnome-session-x11-services.target',
                         'gnome-session-x11-services-ready.target',
                         'gnome-session@.target',
@@ -161,10 +145,6 @@ endforeach
 
 data = files('hardware-compatibility')
 
-if enable_session_selector
-  data += files('session-selector.ui')
-endif
-
 install_data(
   data,
   install_dir: session_pkgdatadir
diff --git a/data/session-selector.ui b/data/session-selector.ui
deleted file mode 100644
index 1c55712db..000000000
--- a/data/session-selector.ui
+++ /dev/null
@@ -1,195 +0,0 @@
-<?xml version="1.0"?>
-<interface>
-  <requires lib="gtk+" version="2.16"/>
-  <!-- interface-naming-policy project-wide -->
-  <object class="GtkListStore" id="session-store">
-    <columns>
-      <!-- column-name name -->
-      <column type="gchararray"/>
-    </columns>
-  </object>
-  <object class="GtkTreeModelSort" id="sort-model">
-    <property name="model">session-store</property>
-  </object>
-  <object class="GtkWindow" id="main-window">
-    <property name="title" translatable="yes">Custom Session</property>
-    <property name="window_position">center</property>
-    <property name="default_width">500</property>
-    <property name="default_height">310</property>
-    <property name="decorated">False</property>
-    <child>
-      <object class="GtkFrame" id="frame1">
-        <property name="visible">True</property>
-        <property name="label_xalign">0.5</property>
-        <property name="shadow_type">out</property>
-        <child>
-          <object class="GtkAlignment" id="alignment3">
-            <property name="visible">True</property>
-            <property name="border_width">12</property>
-            <child>
-              <object class="GtkVBox" id="vbox3">
-                <property name="visible">True</property>
-                <property name="orientation">vertical</property>
-                <property name="spacing">6</property>
-
-                <child>
-                  <object class="GtkInfoBar" id="info-bar">
-                    <property name="visible">True</property>
-                    <property name="message-type">other</property>
-
-                    <child internal-child="content_area">
-                      <object class="GtkHBox" id="info-bar-content_area">
-                        <property name="visible">True</property>
-                        <property name="orientation">vertical</property>
-                        <property name="spacing">0</property>
-                        <child>
-                          <object class="GtkLabel" id="info-label">
-                            <property name="visible">True</property>
-                            <property name="xalign">0.0</property>
-                            <property name="yalign">0.5</property>
-                            <property name="label" translatable="yes">Please select a custom session to run</property>
-                          </object>
-                          <packing>
-                            <property name="expand">True</property>
-                            <property name="fill">True</property>
-                            <property name="position">0</property>
-                          </packing>
-                        </child>
-                      </object>
-                    </child>
-                  </object>
-                  <packing>
-                    <property name="expand">False</property>
-                    <property name="fill">True</property>
-                    <property name="position">0</property>
-                  </packing>
-                </child>
-                <child>
-                  <object class="GtkVBox" id="vbox4">
-                    <property name="visible">True</property>
-                    <property name="orientation">vertical</property>
-                    <property name="spacing">12</property>
-                    <child>
-                      <object class="GtkHBox" id="hbox3">
-                        <property name="visible">True</property>
-                        <property name="spacing">12</property>
-                        <child>
-                          <object class="GtkScrolledWindow" id="scrolledwindow2">
-                            <property name="visible">True</property>
-                            <property name="can_focus">True</property>
-                            <property name="hscrollbar_policy">never</property>
-                            <property name="vscrollbar_policy">automatic</property>
-                            <property name="shadow_type">in</property>
-                            <child>
-                              <object class="GtkTreeView" id="session-list">
-                                <property name="visible">True</property>
-                                <property name="can_focus">True</property>
-                                <property name="headers_visible">False</property>
-                                <property name="search_column">0</property>
-                                <property name="model">sort-model</property>
-                              </object>
-                            </child>
-                          </object>
-                          <packing>
-                            <property name="position">0</property>
-                          </packing>
-                        </child>
-                        <child>
-                          <object class="GtkVButtonBox" id="vbuttonbox2">
-                            <property name="visible">True</property>
-                            <property name="orientation">vertical</property>
-                            <property name="spacing">6</property>
-                            <property name="layout_style">start</property>
-                            <child>
-                              <object class="GtkButton" id="new-session">
-                                <property name="label" translatable="yes">_New Session</property>
-                                <property name="visible">True</property>
-                                <property name="can_focus">True</property>
-                                <property name="receives_default">True</property>
-                                <property name="use_underline">True</property>
-                              </object>
-                              <packing>
-                                <property name="expand">False</property>
-                                <property name="fill">False</property>
-                                <property name="position">0</property>
-                              </packing>
-                            </child>
-                            <child>
-                              <object class="GtkButton" id="remove-session">
-                                <property name="label" translatable="yes">_Remove Session</property>
-                                <property name="visible">True</property>
-                                <property name="can_focus">True</property>
-                                <property name="receives_default">True</property>
-                                <property name="use_underline">True</property>
-                              </object>
-                              <packing>
-                                <property name="expand">False</property>
-                                <property name="fill">False</property>
-                                <property name="position">1</property>
-                              </packing>
-                            </child>
-                            <child>
-                              <object class="GtkButton" id="rename-session">
-                                <property name="label" translatable="yes">Rena_me Session</property>
-                                <property name="visible">True</property>
-                                <property name="can_focus">True</property>
-                                <property name="receives_default">True</property>
-                                <property name="use_underline">True</property>
-                              </object>
-                              <packing>
-                                <property name="expand">False</property>
-                                <property name="fill">False</property>
-                                <property name="position">2</property>
-                              </packing>
-                            </child>
-                          </object>
-                          <packing>
-                            <property name="expand">False</property>
-                            <property name="position">1</property>
-                          </packing>
-                        </child>
-                      </object>
-                      <packing>
-                        <property name="position">1</property>
-                      </packing>
-                    </child>
-                  </object>
-                  <packing>
-                    <property name="position">1</property>
-                  </packing>
-                </child>
-                <child>
-                  <object class="GtkHButtonBox" id="hbuttonbox2">
-                    <property name="visible">True</property>
-                    <property name="spacing">6</property>
-                    <property name="layout_style">end</property>
-                    <child>
-                      <object class="GtkButton" id="continue-button">
-                        <property name="label" translatable="yes">_Continue</property>
-                        <property name="visible">True</property>
-                        <property name="can_focus">True</property>
-                        <property name="can_default">True</property>
-                        <property name="has_default">True</property>
-                        <property name="receives_default">True</property>
-                        <property name="use_underline">True</property>
-                      </object>
-                      <packing>
-                        <property name="expand">False</property>
-                        <property name="fill">False</property>
-                        <property name="position">0</property>
-                      </packing>
-                    </child>
-                  </object>
-                  <packing>
-                    <property name="expand">False</property>
-                    <property name="position">2</property>
-                  </packing>
-                </child>
-              </object>
-            </child>
-          </object>
-        </child>
-      </object>
-    </child>
-  </object>
-</interface>
diff --git a/doc/man/gnome-session-selector.xml b/doc/man/gnome-session-selector.xml
deleted file mode 100644
index 7beb1e47b..000000000
--- a/doc/man/gnome-session-selector.xml
+++ /dev/null
@@ -1,52 +0,0 @@
-<refentry id="gnome-session-selector" lang="en">
-
-<refentryinfo>
-<title>gnome-session-selector</title>
-<productname>gnome-session</productname>
-</refentryinfo>
-
-<refmeta>
-<refentrytitle>gnome-session-selector</refentrytitle>
-<manvolnum>1</manvolnum>
-<refmiscinfo class="manual">User Commands</refmiscinfo>
-</refmeta>
-
-<refnamediv>
-<refname>gnome-session-selector</refname>
-<refpurpose>Selects a session to use with gnome-session</refpurpose>
-</refnamediv>
-
-<refsynopsisdiv>
-<cmdsynopsis>
-<command>gnome-session-selector</command>
-<arg choice="opt">session</arg>
-</cmdsynopsis>
-</refsynopsisdiv>
-
-<refsect1><title>Description</title>
-<para><command>gnome-session-selector</command> can be used from a
-xsession desktop file to select a session before gnome-session is run.
-gnome-session reads and stores its session in the
-<filename><envar>$XDG_DATA_HOME</envar>/gnome-session/saved-session</filename>
-directory. <command>gnome-session-selector</command> works by replacing
-the saved-session directory by a symlink to another directory. Since the
-session name is used as the directory name, it may not contain '/' characters
-or begin with a '.'.
-</para>
-<para>
-When a session name is specified, <command>gnome-session-selector</command>
-will create a symlink to select this session.
-</para>
-<para>
-When started without arguments, <command>gnome-session-selector</command>
-will present a dialog that allows to choose one of the existing sessions
-or create a new one.
-</para>
-</refsect1>
-
-<refsect1><title>See also</title>
-<para>
-<citerefentry><refentrytitle>gnome-session</refentrytitle><manvolnum>1</manvolnum></citerefentry>
-</para>
-</refsect1>
-</refentry>
diff --git a/doc/man/gnome-session.1 b/doc/man/gnome-session.1
index 305454513..1058c4493 100644
--- a/doc/man/gnome-session.1
+++ b/doc/man/gnome-session.1
@@ -30,8 +30,6 @@ applications in the \fB$XDG_CONFIG_HOME/gnome-session/saved-session\fP
 directory. Saving sessions is only supported with the legacy non-systemd
 startup method.
 .PP
-\fIgnome-session\fP is an X11R6 session manager. It can manage GNOME
-applications as well as any X11R6 SM compliant application.
 .SH OPTIONS
 The following options are supported:
 .TP
@@ -100,11 +98,11 @@ Generic unit that will be active throughout the session. Similar to
 Used for tasks that need to be done before session startup. Similar to
 \fBgraphical-session-pre.target\fP.
 .TP
-.I "gnome-session-x11@SESSION.target" "gnome-session-wayland@SESSION.target"
-Main unit started for X11/wayland based session. \fBSESSION\fP is set according
+.I "gnome-session-wayland@SESSION.target"
+Main unit started for the wayland based session. \fBSESSION\fP is set according
 to the session that is passed in \fI--session\fP.
 .TP
-.I "gnome-session-x11.target" "gnome-session-wayland.target"
+.I "gnome-session-wayland.target"
 Convenience units without the session embedded into the target.
 .TP
 .I "gnome-session@SESSION.target"
diff --git a/doc/man/meson.build b/doc/man/meson.build
index b056ce9a1..3b3ecf565 100644
--- a/doc/man/meson.build
+++ b/doc/man/meson.build
@@ -16,10 +16,6 @@ xsltproc_cmd = [
 
 mans = ['gnome-session-inhibit']
 
-if enable_session_selector
-  mans += 'gnome-session-selector'
-endif
-
 foreach man: mans
   output = man + '.1'
 
diff --git a/gnome-session/gsm-autostart-app.h b/gnome-session/gsm-autostart-app.h
index e311061bc..91a74a678 100644
--- a/gnome-session/gsm-autostart-app.h
+++ b/gnome-session/gsm-autostart-app.h
@@ -22,8 +22,6 @@
 
 #include "gsm-app.h"
 
-#include <X11/SM/SMlib.h>
-
 G_BEGIN_DECLS
 
 #define GSM_TYPE_AUTOSTART_APP            (gsm_autostart_app_get_type ())
diff --git a/gnome-session/gsm-fail-whale-dialog.c b/gnome-session/gsm-fail-whale-dialog.c
index d6e8407f5..37487c437 100644
--- a/gnome-session/gsm-fail-whale-dialog.c
+++ b/gnome-session/gsm-fail-whale-dialog.c
@@ -28,9 +28,6 @@
 #include <glib/gi18n.h>
 
 #include <gtk/gtk.h>
-#ifdef GDK_WINDOWING_X11
-#include <gtk/gtkx.h>
-#endif
 
 #include "gsm-fail-whale-dialog.h"
 
@@ -55,27 +52,6 @@ _window_override_user_time (GsmFailWhaleDialog *window)
 {
         guint32 ev_time = gtk_get_current_event_time ();
         GdkWindow *gdk_window = gtk_widget_get_window (GTK_WIDGET (window));
-
-#ifdef GDK_WINDOWING_X11
-        if (!GDK_IS_X11_WINDOW (gdk_window))
-                return;
-
-        if (ev_time == 0) {
-                gint ev_mask = gtk_widget_get_events (GTK_WIDGET (window));
-                if (!(ev_mask & GDK_PROPERTY_CHANGE_MASK)) {
-                        gtk_widget_add_events (GTK_WIDGET (window),
-                                               GDK_PROPERTY_CHANGE_MASK);
-                }
-
-                /*
-                 * NOTE: Last resort for D-BUS or other non-interactive
-                 *       openings.  Causes roundtrip to server.  Lame.
-                 */
-                ev_time = gdk_x11_get_server_time (gdk_window);
-        }
-
-        gdk_x11_window_set_user_time (gdk_window, ev_time);
-#endif
 }
 
 static void
diff --git a/gnome-session/gsm-manager.c b/gnome-session/gsm-manager.c
index ac2d6f04b..aadc6774c 100644
--- a/gnome-session/gsm-manager.c
+++ b/gnome-session/gsm-manager.c
@@ -49,8 +49,6 @@
 #include "gsm-presence.h"
 #include "gsm-shell.h"
 
-#include "gsm-xsmp-server.h"
-#include "gsm-xsmp-client.h"
 #include "gsm-dbus-client.h"
 
 #include "gsm-autostart-app.h"
@@ -123,7 +121,6 @@ typedef struct
         GsmInhibitorFlag        inhibited_actions;
         GsmStore               *apps;
         GsmPresence            *presence;
-        GsmXsmpServer          *xsmp_server;
 
         char                   *session_name;
         gboolean                is_fallback_session : 1;
@@ -1405,7 +1402,6 @@ start_phase (GsmManager *manager)
                                  "PRIORITY=%d", 5,
                                  "MESSAGE=Entering running state",
                                  NULL);
-                gsm_xsmp_server_start_accepting_new_clients (priv->xsmp_server);
                 if (priv->pending_end_session_tasks != NULL)
                         complete_end_session_tasks (manager);
                 g_object_unref (priv->end_session_cancellable);
@@ -1414,7 +1410,6 @@ start_phase (GsmManager *manager)
                 update_idle (manager);
                 break;
         case GSM_MANAGER_PHASE_QUERY_END_SESSION:
-                gsm_xsmp_server_stop_accepting_new_clients (priv->xsmp_server);
                 do_phase_query_end_session (manager);
                 break;
         case GSM_MANAGER_PHASE_END_SESSION:
@@ -1473,13 +1468,10 @@ debug_app_summary (GsmManager *manager)
 void
 gsm_manager_start (GsmManager *manager)
 {
-        GsmManagerPrivate *priv = gsm_manager_get_instance_private (manager);
-
         g_debug ("GsmManager: GSM starting to manage");
 
         g_return_if_fail (GSM_IS_MANAGER (manager));
 
-        gsm_xsmp_server_start (priv->xsmp_server);
         gsm_manager_set_phase (manager, GSM_MANAGER_PHASE_EARLY_INITIALIZATION);
         debug_app_summary (manager);
         start_phase (manager);
@@ -1877,82 +1869,6 @@ on_client_disconnected (GsmClient  *client,
         }
 }
 
-static gboolean
-on_xsmp_client_register_request (GsmXSMPClient *client,
-                                 char         **id,
-                                 GsmManager    *manager)
-{
-        GsmManagerPrivate *priv = gsm_manager_get_instance_private (manager);
-        gboolean handled;
-        char    *new_id;
-        GsmApp  *app;
-
-        handled = TRUE;
-        new_id = NULL;
-
-        if (priv->phase >= GSM_MANAGER_PHASE_QUERY_END_SESSION) {
-                goto out;
-        }
-
-        if (IS_STRING_EMPTY (*id)) {
-                new_id = gsm_util_generate_startup_id ();
-        } else {
-                GsmClient *client;
-
-                client = (GsmClient *)gsm_store_find (priv->clients,
-                                                      (GsmStoreFunc)_client_has_startup_id,
-                                                      *id);
-                /* We can't have two clients with the same id. */
-                if (client != NULL) {
-                        goto out;
-                }
-
-                new_id = g_strdup (*id);
-        }
-
-        g_debug ("GsmManager: Adding new client %s to session", new_id);
-
-        g_signal_connect (client,
-                          "disconnected",
-                          G_CALLBACK (on_client_disconnected),
-                          manager);
-
-        /* If it's a brand new client id, we just accept the client*/
-        if (IS_STRING_EMPTY (*id)) {
-                goto out;
-        }
-
-        app = find_app_for_startup_id (manager, new_id);
-        if (app != NULL) {
-                gsm_client_set_app_id (GSM_CLIENT (client), gsm_app_peek_app_id (app));
-                goto out;
-        }
-
-        /* app not found */
-        g_free (new_id);
-        new_id = NULL;
-
- out:
-        g_free (*id);
-        *id = new_id;
-
-        return handled;
-}
-
-static void
-on_xsmp_client_register_confirmed (GsmXSMPClient *client,
-                                   const gchar   *id,
-                                   GsmManager    *manager)
-{
-        GsmApp *app;
-
-        app = find_app_for_startup_id (manager, id);
-
-        if (app != NULL) {
-                gsm_app_set_registered (app, TRUE);
-        }
-}
-
 static gboolean
 auto_save_is_enabled (GsmManager *manager)
 {
@@ -2105,28 +2021,6 @@ on_client_end_session_response (GsmClient  *client,
                                              reason);
 }
 
-static void
-on_xsmp_client_logout_request (GsmXSMPClient *client,
-                               gboolean       show_dialog,
-                               GsmManager    *manager)
-{
-        GError *error;
-        int     logout_mode;
-
-        if (show_dialog) {
-                logout_mode = GSM_MANAGER_LOGOUT_MODE_NORMAL;
-        } else {
-                logout_mode = GSM_MANAGER_LOGOUT_MODE_NO_CONFIRMATION;
-        }
-
-        error = NULL;
-        gsm_manager_logout (manager, logout_mode, &error);
-        if (error != NULL) {
-                g_warning ("Unable to logout: %s", error->message);
-                g_error_free (error);
-        }
-}
-
 static void
 on_store_client_added (GsmStore   *store,
                        const char *id,
@@ -2139,22 +2033,6 @@ on_store_client_added (GsmStore   *store,
 
         client = (GsmClient *)gsm_store_lookup (store, id);
 
-        /* a bit hacky */
-        if (GSM_IS_XSMP_CLIENT (client)) {
-                g_signal_connect (client,
-                                  "register-request",
-                                  G_CALLBACK (on_xsmp_client_register_request),
-                                  manager);
-                g_signal_connect (client,
-                                  "register-confirmed",
-                                  G_CALLBACK (on_xsmp_client_register_confirmed),
-                                  manager);
-                g_signal_connect (client,
-                                  "logout-request",
-                                  G_CALLBACK (on_xsmp_client_logout_request),
-                                  manager);
-        }
-
         g_signal_connect (client,
                           "end-session-response",
                           G_CALLBACK (on_client_end_session_response),
@@ -2203,22 +2081,6 @@ gsm_manager_set_client_store (GsmManager *manager,
         g_debug ("GsmManager: setting client store %p", store);
 
         priv->clients = store;
-
-        if (priv->clients != NULL) {
-                if (priv->xsmp_server)
-                        g_object_unref (priv->xsmp_server);
-
-                priv->xsmp_server = gsm_xsmp_server_new (store);
-
-                g_signal_connect (priv->clients,
-                                  "added",
-                                  G_CALLBACK (on_store_client_added),
-                                  manager);
-                g_signal_connect (priv->clients,
-                                  "removed",
-                                  G_CALLBACK (on_store_client_removed),
-                                  manager);
-        }
 }
 
 static void
@@ -2392,7 +2254,6 @@ gsm_manager_dispose (GObject *object)
         g_debug ("GsmManager: disposing manager");
 
         g_clear_object (&priv->end_session_cancellable);
-        g_clear_object (&priv->xsmp_server);
         g_clear_pointer (&priv->session_name, g_free);
 
         if (priv->clients != NULL) {
diff --git a/gnome-session/gsm-systemd.c b/gnome-session/gsm-systemd.c
index 9361496e9..cc2a4573f 100644
--- a/gnome-session/gsm-systemd.c
+++ b/gnome-session/gsm-systemd.c
@@ -268,7 +268,7 @@ static void sd_proxy_signal_cb (GDBusProxy  *proxy,
 static gboolean
 _systemd_session_is_graphical (const char *session_id)
 {
-        const gchar * const graphical_session_types[] = { "wayland", "x11", "mir", NULL };
+        const gchar * const graphical_session_types[] = { "wayland", "mir", NULL };
         int saved_errno;
         g_autofree gchar *type = NULL;
 
@@ -1086,8 +1086,7 @@ gsm_systemd_is_last_session_for_user (GsmSystem *system)
                 if (ret != 0)
                         continue;
 
-                if (g_strcmp0 (type, "x11") != 0 &&
-                    g_strcmp0 (type, "wayland") != 0) {
+                if (g_strcmp0 (type, "wayland") != 0) {
                         free (type);
                         continue;
                 }
diff --git a/gnome-session/gsm-xsmp-server.c b/gnome-session/gsm-xsmp-server.c
deleted file mode 100644
index e05c6d77e..000000000
--- a/gnome-session/gsm-xsmp-server.c
+++ /dev/null
@@ -1,746 +0,0 @@
-/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
- *
- * Copyright (C) 2007 Novell, Inc.
- * Copyright (C) 2008 Red Hat, Inc.
- * Copyright (C) 2008 William Jon McCann <jmccann@redhat.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, see <http://www.gnu.org/licenses/>.
- *
- */
-
-#include "config.h"
-
-#include <errno.h>
-#include <stdlib.h>
-#include <stdio.h>
-#include <unistd.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <fcntl.h>
-#include <string.h>
-
-#include <glib.h>
-#include <glib/gi18n.h>
-#include <glib-object.h>
-
-#include <X11/ICE/ICElib.h>
-#include <X11/ICE/ICEutil.h>
-#include <X11/ICE/ICEconn.h>
-#include <X11/SM/SMlib.h>
-
-/* Get the proto for _IceTransNoListen */
-#define ICE_t
-#define TRANS_SERVER
-#include <X11/Xtrans/Xtrans.h>
-#undef  ICE_t
-#undef TRANS_SERVER
-
-#include "gsm-xsmp-server.h"
-#include "gsm-xsmp-client.h"
-#include "gsm-util.h"
-
-/* ICEauthority stuff */
-/* Various magic numbers stolen from iceauth.c */
-#define GSM_ICE_AUTH_RETRIES      10
-#define GSM_ICE_AUTH_INTERVAL     2   /* 2 seconds */
-#define GSM_ICE_AUTH_LOCK_TIMEOUT 600 /* 10 minutes */
-
-#define GSM_ICE_MAGIC_COOKIE_AUTH_NAME "MIT-MAGIC-COOKIE-1"
-#define GSM_ICE_MAGIC_COOKIE_LEN       16
-
-#define GSM_XSMP_SERVER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GSM_TYPE_XSMP_SERVER, GsmXsmpServerPrivate))
-
-struct _GsmXsmpServer
-{
-        GObject         parent_instance;
-
-        GsmStore       *client_store;
-
-        IceListenObj   *xsmp_sockets;
-        int             num_xsmp_sockets;
-        int             num_local_xsmp_sockets;
-        gboolean        stopping;
-};
-
-enum {
-        PROP_0,
-        PROP_CLIENT_STORE
-};
-
-static void     gsm_xsmp_server_class_init  (GsmXsmpServerClass *klass);
-static void     gsm_xsmp_server_init        (GsmXsmpServer      *xsmp_server);
-static void     gsm_xsmp_server_finalize    (GObject         *object);
-
-static gpointer xsmp_server_object = NULL;
-
-G_DEFINE_TYPE (GsmXsmpServer, gsm_xsmp_server, G_TYPE_OBJECT)
-
-typedef struct {
-        GsmXsmpServer *server;
-        IceListenObj   listener;
-} GsmIceConnectionData;
-
-typedef struct {
-        guint watch_id;
-        guint protocol_timeout;
-} GsmIceConnectionWatch;
-
-static void
-disconnect_ice_connection (IceConn ice_conn)
-{
-        IceSetShutdownNegotiation (ice_conn, FALSE);
-        IceCloseConnection (ice_conn);
-}
-
-static void
-free_ice_connection_watch (GsmIceConnectionWatch *data)
-{
-        if (data->watch_id) {
-                g_source_remove (data->watch_id);
-                data->watch_id = 0;
-        }
-
-        if (data->protocol_timeout) {
-                g_source_remove (data->protocol_timeout);
-                data->protocol_timeout = 0;
-        }
-
-        g_free (data);
-}
-
-static gboolean
-ice_protocol_timeout (IceConn ice_conn)
-{
-        GsmIceConnectionWatch *data;
-
-        g_debug ("GsmXsmpServer: ice_protocol_timeout for IceConn %p with status %d",
-                 ice_conn, IceConnectionStatus (ice_conn));
-
-        data = ice_conn->context;
-
-        free_ice_connection_watch (data);
-        disconnect_ice_connection (ice_conn);
-
-        return FALSE;
-}
-
-static gboolean
-auth_iochannel_watch (GIOChannel   *source,
-                      GIOCondition  condition,
-                      IceConn       ice_conn)
-{
-
-        GsmIceConnectionWatch *data;
-        gboolean               keep_going;
-
-        data = ice_conn->context;
-
-        switch (IceProcessMessages (ice_conn, NULL, NULL)) {
-        case IceProcessMessagesSuccess:
-                keep_going = TRUE;
-                break;
-        case IceProcessMessagesIOError:
-                g_debug ("GsmXsmpServer: IceProcessMessages returned IceProcessMessagesIOError");
-                free_ice_connection_watch (data);
-                disconnect_ice_connection (ice_conn);
-                keep_going = FALSE;
-                break;
-        case IceProcessMessagesConnectionClosed:
-                g_debug ("GsmXsmpServer: IceProcessMessages returned IceProcessMessagesConnectionClosed");
-                free_ice_connection_watch (data);
-                keep_going = FALSE;
-                break;
-        default:
-                g_assert_not_reached ();
-        }
-
-        return keep_going;
-}
-
-/* IceAcceptConnection returns a new ICE connection that is in a "pending" state,
- * this is because authentification may be necessary.
- * So we've to authenticate it, before accept_xsmp_connection() is called.
- * Then each GsmXSMPClient will have its own IceConn watcher
- */
-static void
-auth_ice_connection (IceConn ice_conn)
-{
-        GIOChannel            *channel;
-        GsmIceConnectionWatch *data;
-        int                    fd;
-
-        g_debug ("GsmXsmpServer: auth_ice_connection()");
-
-        fd = IceConnectionNumber (ice_conn);
-        fcntl (fd, F_SETFD, fcntl (fd, F_GETFD, 0) | FD_CLOEXEC);
-        channel = g_io_channel_unix_new (fd);
-
-        data = g_new0 (GsmIceConnectionWatch, 1);
-        ice_conn->context = data;
-
-        data->protocol_timeout = g_timeout_add_seconds (5,
-                                                        (GSourceFunc)ice_protocol_timeout,
-                                                        ice_conn);
-        data->watch_id = g_io_add_watch (channel,
-                                         G_IO_IN | G_IO_ERR,
-                                         (GIOFunc)auth_iochannel_watch,
-                                         ice_conn);
-        g_io_channel_unref (channel);
-}
-
-/* This is called (by glib via xsmp->ice_connection_watch) when a
- * connection is first received on the ICE listening socket.
- */
-static gboolean
-accept_ice_connection (GIOChannel           *source,
-                       GIOCondition          condition,
-                       GsmIceConnectionData *data)
-{
-        IceConn         ice_conn;
-        IceAcceptStatus status;
-
-        g_debug ("GsmXsmpServer: accept_ice_connection()");
-
-        ice_conn = IceAcceptConnection (data->listener, &status);
-        if (status != IceAcceptSuccess) {
-                g_debug ("GsmXsmpServer: IceAcceptConnection returned %d", status);
-                return TRUE;
-        }
-
-        auth_ice_connection (ice_conn);
-
-        return TRUE;
-}
-
-void
-gsm_xsmp_server_start (GsmXsmpServer *server)
-{
-        GIOChannel *channel;
-        int         i;
-
-        for (i = 0; i < server->num_local_xsmp_sockets; i++) {
-                GsmIceConnectionData *data;
-
-                data = g_new0 (GsmIceConnectionData, 1);
-                data->server = server;
-                data->listener = server->xsmp_sockets[i];
-
-                channel = g_io_channel_unix_new (IceGetListenConnectionNumber (server->xsmp_sockets[i]));
-                g_io_add_watch_full (channel,
-                                     G_PRIORITY_DEFAULT,
-                                     G_IO_IN | G_IO_HUP | G_IO_ERR,
-                                     (GIOFunc)accept_ice_connection,
-                                     data,
-                                     (GDestroyNotify)g_free);
-                g_io_channel_unref (channel);
-        }
-}
-
-void
-gsm_xsmp_server_stop_accepting_new_clients (GsmXsmpServer *server)
-{
-        g_return_if_fail (GSM_IS_XSMP_SERVER (server));
-        g_debug ("gsm_xsmp_server_stop_accepting_new_clients");
-        server->stopping = TRUE;
-}
-
-void
-gsm_xsmp_server_start_accepting_new_clients (GsmXsmpServer *server)
-{
-        g_return_if_fail (GSM_IS_XSMP_SERVER (server));
-        g_debug ("gsm_xsmp_server_start");
-        server->stopping = FALSE;
-}
-
-static void
-gsm_xsmp_server_set_client_store (GsmXsmpServer *xsmp_server,
-                                  GsmStore      *store)
-{
-        g_return_if_fail (GSM_IS_XSMP_SERVER (xsmp_server));
-
-        if (store != NULL) {
-                g_object_ref (store);
-        }
-
-        if (xsmp_server->client_store != NULL) {
-                g_object_unref (xsmp_server->client_store);
-        }
-
-        xsmp_server->client_store = store;
-}
-
-static void
-gsm_xsmp_server_set_property (GObject      *object,
-                              guint         prop_id,
-                              const GValue *value,
-                              GParamSpec   *pspec)
-{
-        GsmXsmpServer *self;
-
-        self = GSM_XSMP_SERVER (object);
-
-        switch (prop_id) {
-        case PROP_CLIENT_STORE:
-                gsm_xsmp_server_set_client_store (self, g_value_get_object (value));
-                break;
-         default:
-                G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
-                break;
-        }
-}
-
-static void
-gsm_xsmp_server_get_property (GObject    *object,
-                              guint       prop_id,
-                              GValue     *value,
-                              GParamSpec *pspec)
-{
-        GsmXsmpServer *self;
-
-        self = GSM_XSMP_SERVER (object);
-
-        switch (prop_id) {
-        case PROP_CLIENT_STORE:
-                g_value_set_object (value, self->client_store);
-                break;
-        default:
-                G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
-                break;
-        }
-}
-
-/* This is called (by libSM) when XSMP is initiated on an ICE
- * connection that was already accepted by accept_ice_connection.
- */
-static Status
-accept_xsmp_connection (SmsConn        sms_conn,
-                        GsmXsmpServer *server,
-                        unsigned long *mask_ret,
-                        SmsCallbacks  *callbacks_ret,
-                        char         **failure_reason_ret)
-{
-        IceConn                ice_conn;
-        GsmClient             *client;
-        GsmIceConnectionWatch *data;
-
-        if (server->stopping) {
-                g_debug ("GsmXsmpServer: In shutdown, rejecting new client");
-
-                *failure_reason_ret = strdup (_("Refusing new client connection because the session is currently being shut down\n"));
-                return FALSE;
-        }
-
-        ice_conn = SmsGetIceConnection (sms_conn);
-        data = ice_conn->context;
-
-        /* Each GsmXSMPClient has its own IceConn watcher */
-        free_ice_connection_watch (data);
-
-        client = gsm_xsmp_client_new (ice_conn);
-
-        gsm_store_add (server->client_store, gsm_client_peek_id (client), G_OBJECT (client));
-        /* the store will own the ref */
-        g_object_unref (client);
-
-        gsm_xsmp_client_connect (GSM_XSMP_CLIENT (client), sms_conn, mask_ret, callbacks_ret);
-
-        return TRUE;
-}
-
-static void
-ice_error_handler (IceConn       conn,
-                   Bool          swap,
-                   int           offending_minor_opcode,
-                   unsigned long offending_sequence,
-                   int           error_class,
-                   int           severity,
-                   IcePointer    values)
-{
-        g_debug ("GsmXsmpServer: ice_error_handler (%p, %s, %d, %lx, %d, %d)",
-                 conn, swap ? "TRUE" : "FALSE", offending_minor_opcode,
-                 offending_sequence, error_class, severity);
-
-        if (severity == IceCanContinue) {
-                return;
-        }
-
-        /* FIXME: the ICElib docs are completely vague about what we're
-         * supposed to do in this case. Need to verify that calling
-         * IceCloseConnection() here is guaranteed to cause neither
-         * free-memory-reads nor leaks.
-         */
-        IceCloseConnection (conn);
-}
-
-static void
-ice_io_error_handler (IceConn conn)
-{
-        g_debug ("GsmXsmpServer: ice_io_error_handler (%p)", conn);
-
-        /* We don't need to do anything here; the next call to
-         * IceProcessMessages() for this connection will receive
-         * IceProcessMessagesIOError and we can handle the error there.
-         */
-}
-
-static void
-sms_error_handler (SmsConn       conn,
-                   Bool          swap,
-                   int           offending_minor_opcode,
-                   unsigned long offending_sequence_num,
-                   int           error_class,
-                   int           severity,
-                   IcePointer    values)
-{
-        g_debug ("GsmXsmpServer: sms_error_handler (%p, %s, %d, %lx, %d, %d)",
-                 conn, swap ? "TRUE" : "FALSE", offending_minor_opcode,
-                 offending_sequence_num, error_class, severity);
-
-        /* We don't need to do anything here; if the connection needs to be
-         * closed, libSM will do that itself.
-         */
-}
-
-static IceAuthFileEntry *
-auth_entry_new (const char *protocol,
-                const char *network_id)
-{
-        IceAuthFileEntry *file_entry;
-        IceAuthDataEntry  data_entry;
-
-        file_entry = malloc (sizeof (IceAuthFileEntry));
-
-        file_entry->protocol_name = strdup (protocol);
-        file_entry->protocol_data = NULL;
-        file_entry->protocol_data_length = 0;
-        file_entry->network_id = strdup (network_id);
-        file_entry->auth_name = strdup (GSM_ICE_MAGIC_COOKIE_AUTH_NAME);
-        file_entry->auth_data = IceGenerateMagicCookie (GSM_ICE_MAGIC_COOKIE_LEN);
-        file_entry->auth_data_length = GSM_ICE_MAGIC_COOKIE_LEN;
-
-        /* Also create an in-memory copy, which is what the server will
-         * actually use for checking client auth.
-         */
-        data_entry.protocol_name = file_entry->protocol_name;
-        data_entry.network_id = file_entry->network_id;
-        data_entry.auth_name = file_entry->auth_name;
-        data_entry.auth_data = file_entry->auth_data;
-        data_entry.auth_data_length = file_entry->auth_data_length;
-        IceSetPaAuthData (1, &data_entry);
-
-        return file_entry;
-}
-
-static gboolean
-update_iceauthority (GsmXsmpServer *server,
-                     gboolean       adding)
-{
-        char             *filename;
-        char            **our_network_ids;
-        FILE             *fp;
-        IceAuthFileEntry *auth_entry;
-        GSList           *entries;
-        GSList           *e;
-        int               i;
-        int               ret;
-        gboolean          ok = FALSE;
-
-        filename = IceAuthFileName ();
-        do {
-                ret = IceLockAuthFile (filename,
-                                       GSM_ICE_AUTH_RETRIES,
-                                       GSM_ICE_AUTH_INTERVAL,
-                                       GSM_ICE_AUTH_LOCK_TIMEOUT);
-
-        } while (ret != IceAuthLockSuccess && errno == EINTR);
-
-        if (ret != IceAuthLockSuccess) {
-                g_warning ("IceLockAuthFile failed: %m");
-                return FALSE;
-        }
-
-        our_network_ids = g_malloc (server->num_local_xsmp_sockets * sizeof (char *));
-        for (i = 0; i < server->num_local_xsmp_sockets; i++) {
-                our_network_ids[i] = IceGetListenConnectionString (server->xsmp_sockets[i]);
-        }
-
-        entries = NULL;
-
-        fp = fopen (filename, "r+");
-        if (fp != NULL) {
-                while ((auth_entry = IceReadAuthFileEntry (fp)) != NULL) {
-                        /* Skip/delete entries with no network ID (invalid), or with
-                         * our network ID; if we're starting up, an entry with our
-                         * ID must be a stale entry left behind by an old process,
-                         * and if we're shutting down, it won't be valid in the
-                         * future, so either way we want to remove it from the list.
-                         */
-                        if (!auth_entry->network_id) {
-                                IceFreeAuthFileEntry (auth_entry);
-                                continue;
-                        }
-
-                        for (i = 0; i < server->num_local_xsmp_sockets; i++) {
-                                if (!strcmp (auth_entry->network_id, our_network_ids[i])) {
-                                        IceFreeAuthFileEntry (auth_entry);
-                                        break;
-                                }
-                        }
-                        if (i != server->num_local_xsmp_sockets) {
-                                continue;
-                        }
-
-                        entries = g_slist_prepend (entries, auth_entry);
-                }
-
-                rewind (fp);
-        } else {
-                int fd;
-
-                if (errno != ENOENT) {
-                        g_warning ("Unable to read ICE authority file %s: %m", filename);
-                        goto cleanup;
-                }
-
-                fd = open (filename, O_CREAT | O_WRONLY, 0600);
-                fp = fdopen (fd, "w");
-                if (!fp) {
-                        g_warning ("Unable to write to ICE authority file: %s", filename);
-                        if (fd != -1) {
-                                close (fd);
-                        }
-                        goto cleanup;
-                }
-        }
-
-        if (adding) {
-                for (i = 0; i < server->num_local_xsmp_sockets; i++) {
-                        entries = g_slist_append (entries,
-                                                  auth_entry_new ("ICE", our_network_ids[i]));
-                        entries = g_slist_prepend (entries,
-                                                   auth_entry_new ("XSMP", our_network_ids[i]));
-                }
-        }
-
-        for (e = entries; e; e = e->next) {
-                IceAuthFileEntry *auth_entry = e->data;
-                IceWriteAuthFileEntry (fp, auth_entry);
-                IceFreeAuthFileEntry (auth_entry);
-        }
-        g_slist_free (entries);
-
-        fclose (fp);
-        ok = TRUE;
-
- cleanup:
-        IceUnlockAuthFile (filename);
-        for (i = 0; i < server->num_local_xsmp_sockets; i++) {
-                free (our_network_ids[i]);
-        }
-        g_free (our_network_ids);
-
-        return ok;
-}
-
-
-static void
-setup_listener (GsmXsmpServer *server)
-{
-        char   error[256];
-        mode_t saved_umask;
-        char  *network_id_list;
-        int    i;
-        int    res;
-
-        /* Set up sane error handlers */
-        IceSetErrorHandler (ice_error_handler);
-        IceSetIOErrorHandler (ice_io_error_handler);
-        SmsSetErrorHandler (sms_error_handler);
-
-        /* Initialize libSM; we pass NULL for hostBasedAuthProc to disable
-         * host-based authentication.
-         */
-        res = SmsInitialize (PACKAGE,
-                             VERSION,
-                             (SmsNewClientProc)accept_xsmp_connection,
-                             server,
-                             NULL,
-                             sizeof (error),
-                             error);
-        if (! res) {
-                gsm_util_init_error (TRUE, "Could not initialize libSM: %s", error);
-        }
-
-        /* By default, IceListenForConnections will open one socket for each
-         * transport type known to X. We don't want connections from remote
-         * hosts, so for security reasons it would be best if ICE didn't
-         * even open any non-local sockets. So we use an internal ICElib
-         * method to disable them here. Unfortunately, there is no way to
-         * ask X what transport types it knows about, so we're forced to
-         * guess.
-         */
-        _IceTransNoListen ("tcp");
-
-        /* Create the XSMP socket. Older versions of IceListenForConnections
-         * have a bug which causes the umask to be set to 0 on certain types
-         * of failures. Probably not an issue on any modern systems, but
-         * we'll play it safe.
-         */
-        saved_umask = umask (0);
-        umask (saved_umask);
-        res = IceListenForConnections (&server->num_xsmp_sockets,
-                                       &server->xsmp_sockets,
-                                       sizeof (error),
-                                       error);
-        if (! res) {
-                gsm_util_init_error (TRUE, _("Could not create ICE listening socket: %s"), error);
-        }
-
-        umask (saved_umask);
-
-        /* Find the local sockets in the returned socket list and move them
-         * to the start of the list.
-         */
-        for (i = server->num_local_xsmp_sockets = 0; i < server->num_xsmp_sockets; i++) {
-                char *id = IceGetListenConnectionString (server->xsmp_sockets[i]);
-
-                if (!strncmp (id, "local/", sizeof ("local/") - 1) ||
-                    !strncmp (id, "unix/", sizeof ("unix/") - 1)) {
-                        if (i > server->num_local_xsmp_sockets) {
-                                IceListenObj tmp;
-                                tmp = server->xsmp_sockets[i];
-                                server->xsmp_sockets[i] = server->xsmp_sockets[server->num_local_xsmp_sockets];
-                                server->xsmp_sockets[server->num_local_xsmp_sockets] = tmp;
-                        }
-                        server->num_local_xsmp_sockets++;
-                }
-                free (id);
-        }
-
-        if (server->num_local_xsmp_sockets == 0) {
-                gsm_util_init_error (TRUE, "IceListenForConnections did not return a local listener!");
-        }
-
-        if (server->num_local_xsmp_sockets != server->num_xsmp_sockets) {
-                /* Xtrans was apparently compiled with support for some
-                 * non-local transport besides TCP (which we disabled above); we
-                 * won't create IO watches on those extra sockets, so
-                 * connections to them will never be noticed, but they're still
-                 * there, which is inelegant.
-                 *
-                 * If the g_warning below is triggering for you and you want to
-                 * stop it, the fix is to add additional _IceTransNoListen()
-                 * calls above.
-                 */
-                network_id_list = IceComposeNetworkIdList (server->num_xsmp_sockets - server->num_local_xsmp_sockets,
-                                                           server->xsmp_sockets + server->num_local_xsmp_sockets);
-                g_warning ("IceListenForConnections returned %d non-local listeners: %s",
-                           server->num_xsmp_sockets - server->num_local_xsmp_sockets,
-                           network_id_list);
-                free (network_id_list);
-        }
-
-        /* Update .ICEauthority with new auth entries for our socket */
-        if (!update_iceauthority (server, TRUE)) {
-                /* FIXME: is this really fatal? Hm... */
-                gsm_util_init_error (TRUE,
-                                     "Could not update ICEauthority file %s",
-                                     IceAuthFileName ());
-        }
-
-        network_id_list = IceComposeNetworkIdList (server->num_local_xsmp_sockets,
-                                                   server->xsmp_sockets);
-
-        gsm_util_setenv ("SESSION_MANAGER", network_id_list);
-        g_debug ("GsmXsmpServer: SESSION_MANAGER=%s\n", network_id_list);
-        free (network_id_list);
-}
-
-static GObject *
-gsm_xsmp_server_constructor (GType                  type,
-                             guint                  n_construct_properties,
-                             GObjectConstructParam *construct_properties)
-{
-        GsmXsmpServer *xsmp_server;
-
-        xsmp_server = GSM_XSMP_SERVER (G_OBJECT_CLASS (gsm_xsmp_server_parent_class)->constructor (type,
-                                                                                       n_construct_properties,
-                                                                                       construct_properties));
-        setup_listener (xsmp_server);
-
-        return G_OBJECT (xsmp_server);
-}
-
-static void
-gsm_xsmp_server_class_init (GsmXsmpServerClass *klass)
-{
-        GObjectClass   *object_class = G_OBJECT_CLASS (klass);
-
-        object_class->get_property = gsm_xsmp_server_get_property;
-        object_class->set_property = gsm_xsmp_server_set_property;
-        object_class->constructor = gsm_xsmp_server_constructor;
-        object_class->finalize = gsm_xsmp_server_finalize;
-
-        g_object_class_install_property (object_class,
-                                         PROP_CLIENT_STORE,
-                                         g_param_spec_object ("client-store",
-                                                              NULL,
-                                                              NULL,
-                                                              GSM_TYPE_STORE,
-                                                              G_PARAM_READWRITE | G_PARAM_CONSTRUCT));
-}
-
-static void
-gsm_xsmp_server_init (GsmXsmpServer *xsmp_server)
-{
-}
-
-static void
-gsm_xsmp_server_finalize (GObject *object)
-{
-        GsmXsmpServer *xsmp_server;
-
-        g_return_if_fail (object != NULL);
-        g_return_if_fail (GSM_IS_XSMP_SERVER (object));
-
-        xsmp_server = GSM_XSMP_SERVER (object);
-
-        g_return_if_fail (xsmp_server != NULL);
-
-        IceFreeListenObjs (xsmp_server->num_xsmp_sockets,
-                           xsmp_server->xsmp_sockets);
-
-        if (xsmp_server->client_store != NULL) {
-                g_object_unref (xsmp_server->client_store);
-        }
-
-        G_OBJECT_CLASS (gsm_xsmp_server_parent_class)->finalize (object);
-}
-
-GsmXsmpServer *
-gsm_xsmp_server_new (GsmStore *client_store)
-{
-        if (xsmp_server_object != NULL) {
-                g_object_ref (xsmp_server_object);
-        } else {
-                xsmp_server_object = g_object_new (GSM_TYPE_XSMP_SERVER,
-                                                   "client-store", client_store,
-                                                   NULL);
-
-                g_object_add_weak_pointer (xsmp_server_object,
-                                           (gpointer *) &xsmp_server_object);
-        }
-
-        return GSM_XSMP_SERVER (xsmp_server_object);
-}
diff --git a/gnome-session/gsm-xsmp-server.h b/gnome-session/gsm-xsmp-server.h
deleted file mode 100644
index 95d704dcb..000000000
--- a/gnome-session/gsm-xsmp-server.h
+++ /dev/null
@@ -1,40 +0,0 @@
-/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
- *
- * Copyright (C) 2008 William Jon McCann <jmccann@redhat.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, see <http://www.gnu.org/licenses/>.
- *
- */
-
-
-#ifndef __GSM_XSMP_SERVER_H
-#define __GSM_XSMP_SERVER_H
-
-#include <glib-object.h>
-
-#include "gsm-store.h"
-
-G_BEGIN_DECLS
-
-#define GSM_TYPE_XSMP_SERVER         (gsm_xsmp_server_get_type ())
-G_DECLARE_FINAL_TYPE (GsmXsmpServer, gsm_xsmp_server, GSM, XSMP_SERVER, GObject)
-
-GsmXsmpServer *     gsm_xsmp_server_new                            (GsmStore      *client_store);
-void                gsm_xsmp_server_start                          (GsmXsmpServer *server);
-void                gsm_xsmp_server_stop_accepting_new_clients     (GsmXsmpServer *server);
-void                gsm_xsmp_server_start_accepting_new_clients    (GsmXsmpServer *server);
-
-G_END_DECLS
-
-#endif /* __GSM_XSMP_SERVER_H */
diff --git a/gnome-session/meson.build b/gnome-session/meson.build
index 8c221e8c4..909d8b5d9 100644
--- a/gnome-session/meson.build
+++ b/gnome-session/meson.build
@@ -36,8 +36,6 @@ sources = files(
   'gsm-store.c',
   'gsm-system.c',
   'gsm-systemd.c',
-  'gsm-xsmp-client.c',
-  'gsm-xsmp-server.c',
   'main.c'
 )
 
diff --git a/gnome-session/test-inhibit.c b/gnome-session/test-inhibit.c
index 0a8417e65..74d2e476a 100644
--- a/gnome-session/test-inhibit.c
+++ b/gnome-session/test-inhibit.c
@@ -85,6 +85,7 @@ do_inhibit_for_window (GdkWindow *window)
         app_id = "nautilus";
         reason = "A file transfer is in progress.";
 #endif
+        // FIXME: this test assumes x11
         toplevel_xid = gdk_x11_window_get_xid (window);
         flags = GSM_INHIBITOR_FLAG_LOGOUT
                 | GSM_INHIBITOR_FLAG_SWITCH_USER
diff --git a/meson.build b/meson.build
index be7056692..6ab76b3ec 100644
--- a/meson.build
+++ b/meson.build
@@ -82,10 +82,6 @@ glib_req_version = '>= 2.46.0'
 gio_dep = dependency('gio-2.0', version: glib_req_version)
 glib_dep = dependency('glib-2.0', version: glib_req_version)
 gtk_dep = dependency('gtk+-3.0', version: '>= 3.22.0')
-xtrans_dep = dependency('xtrans')
-ice_dep = dependency('ice')
-sm_dep = dependency('sm')
-x11_dep = dependency('x11')
 
 session_deps = [
   gio_dep,
@@ -94,14 +90,7 @@ session_deps = [
   dependency('json-glib-1.0', version: '>= 0.10')
 ]
 
-session_bin_deps = session_deps + [
-  xtrans_dep,
-  ice_dep,
-  sm_dep
-]
-
-# Check for session selector GTK+ UI
-enable_session_selector = get_option('session_selector')
+session_bin_deps = session_deps + []
 
 session_bin_deps += dependency('gio-unix-2.0', version: glib_req_version)
 
diff --git a/meson_options.txt b/meson_options.txt
index f146c55c9..54da4d9b7 100644
--- a/meson_options.txt
+++ b/meson_options.txt
@@ -1,5 +1,4 @@
 option('deprecation_flags', type: 'boolean', value: false, description: 'use *_DISABLE_DEPRECATED flags')
-option('session_selector', type: 'boolean', value: false, description: 'enable building a custom session selector dialog')
 option('systemduserunitdir', type: 'string', description: 'Directory for systemd user service files')
 option('docbook', type: 'boolean', value: true, description: 'build documentation')
 option('man', type: 'boolean', value: true, description: 'build documentation (requires xmlto)')
diff --git a/meson_post_install.py b/meson_post_install.py
index c5caba57b..27017f651 100644
--- a/meson_post_install.py
+++ b/meson_post_install.py
@@ -1,6 +1,8 @@
 #!/usr/bin/env python3
 
 import os
+import shutil
+import subprocess
 import sys
 
 if os.environ.get('DESTDIR'):
@@ -8,8 +10,17 @@ if os.environ.get('DESTDIR'):
 else:
   install_root = sys.argv[1]
 
+if not os.environ.get('DESTDIR'):
+  schemadir = os.path.join(install_root, 'glib-2.0', 'schemas')
+  print('Compile gsettings schemas...')
+  subprocess.call(['glib-compile-schemas', schemadir])
+
 # FIXME: Meson is unable to copy a generated target file:
 #        https://groups.google.com/forum/#!topic/mesonbuild/3iIoYPrN4P0
 dst_dir = os.path.join(install_root, 'wayland-sessions')
 if not os.path.exists(dst_dir):
   os.makedirs(dst_dir)
+
+src = os.path.join(install_root, 'xsessions', 'gnome.desktop')
+dst = os.path.join(dst_dir, 'gnome.desktop')
+shutil.copyfile(src, dst)
diff --git a/tools/gnome-session-check-accelerated-common.h b/tools/gnome-session-check-accelerated-common.h
deleted file mode 100644
index 59631d9cc..000000000
--- a/tools/gnome-session-check-accelerated-common.h
+++ /dev/null
@@ -1,29 +0,0 @@
-/* -*- mode:c; c-basic-offset: 8; indent-tabs-mode: nil; -*- */
-/* Tool to set the property _GNOME_SESSION_ACCELERATED on the root window */
-/*
- * Copyright (C) 2013 SUSE LINUX Products GmbH, Nuernberg, Germany.
- *
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * Author:
- *   Frederic Crozat <fcrozat@suse.com>
- */
-
-/* Exit value for helper */
-#define HELPER_ACCEL 0
-#define HELPER_NO_ACCEL 1
-#define HELPER_SOFTWARE_RENDERING 2
-
diff --git a/tools/gnome-session-check-accelerated-gl-helper.c b/tools/gnome-session-check-accelerated-gl-helper.c
deleted file mode 100644
index 4be96384c..000000000
--- a/tools/gnome-session-check-accelerated-gl-helper.c
+++ /dev/null
@@ -1,517 +0,0 @@
-/* gcc -o gnome-session-accelerated `pkg-config --cflags --libs xcomposite gl` -Wall gnome-session-is-accelerated.c */
-
-/*
- * Copyright (C) 2010      Novell, Inc.
- * Copyright (C) 2006-2009 Red Hat, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * Author:
- *   Vincent Untz <vuntz@gnome.org>
- *
- * Most of the code comes from desktop-effects [1], released under GPLv2+.
- * desktop-effects was written by:
- *   Soren Sandmann <sandmann@redhat.com>
- *
- * [1] http://git.fedorahosted.org/git/?p=desktop-effects.git;a=blob_plain;f=desktop-effects.c;hb=HEAD
- */
-
-/*
- * Here's the rationale behind this helper, quoting Owen, in his mail to the
- * release team:
- * (http://mail.gnome.org/archives/release-team/2010-June/msg00079.html)
- *
- * """
- * There are some limits to what we can do here automatically without
- * knowing anything about the driver situation on the system. The basic
- * problem is that there are all sorts of suck:
- *
- *  * No GL at all. This typically only happens if a system is
- *    misconfigured.
- *
- *  * Only software GL. This one is easy to detect. We have code in
- *    the Fedora desktop-effects tool, etc.
- *
- *  * GL that isn't featureful enough. (Tiny texture size limits, no
- *    texture-from-pixmap, etc.) Possible to detect with more work, but
- *    largely a fringe case.
- *
- *  * Buggy GL. This isn't possible to detect. Except for the case where
- *    all GL programs crash. For that reason, we probably don't want
- *    gnome-session to directly try and do any GL detection; better to
- *    use a helper binary.
- *
- *  * Horribly slow hardware GL. We could theoretically develop some sort
- *    of benchmark, but it's a tricky area. And how slow is too slow?
- * """
- *
- * Some other tools are doing similar checks:
- *  - desktop-effects (Fedora Config Tool) [1]
- *  - drak3d (Mandriva Config Tool) [2]
- *  - compiz-manager (Compiz wrapper) [3]
- *
- * [1] http://git.fedorahosted.org/git/?p=desktop-effects.git;a=blob_plain;f=desktop-effects.c;hb=HEAD
- * [2] http://svn.mandriva.com/cgi-bin/viewvc.cgi/soft/drak3d/trunk/lib/Xconfig/glx.pm?view=markup
- * [3] http://git.compiz.org/fusion/misc/compiz-manager/tree/compiz-manager
- */
-
-/* for strcasestr */
-#define _GNU_SOURCE
-
-#include <ctype.h>
-#include <locale.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <glib.h>
-
-#include <regex.h>
-
-#ifdef __FreeBSD__
-#include <kenv.h>
-#endif
-
-#include <X11/Xlib.h>
-#include <X11/Xatom.h>
-#include <X11/extensions/Xcomposite.h>
-#include <GL/gl.h>
-#include <GL/glx.h>
-
-#include "gnome-session-check-accelerated-common.h"
-
-#define SIZE_UNSET 0
-#define SIZE_ERROR -1
-static int max_texture_size = SIZE_UNSET;
-static int max_renderbuffer_size = SIZE_UNSET;
-static gboolean has_llvmpipe = FALSE;
-
-static inline void
-_print_error (const char *str)
-{
-        fprintf (stderr, "gnome-session-is-accelerated: %s\n", str);
-}
-
-#define CMDLINE_UNSET -1
-#define CMDLINE_NON_FALLBACK_FORCED 0
-#define CMDLINE_FALLBACK_FORCED 1
-
-#if defined(__linux__)
-static int
-_parse_kcmdline (void)
-{
-        int ret = CMDLINE_UNSET;
-        GRegex *regex;
-        GMatchInfo *match;
-        char *contents;
-        char *word;
-        const char *arg;
-
-        if (!g_file_get_contents ("/proc/cmdline", &contents, NULL, NULL))
-                return ret;
-
-        regex = g_regex_new ("gnome.fallback=(\\S+)", 0, G_REGEX_MATCH_NOTEMPTY, NULL);
-        if (!g_regex_match (regex, contents, G_REGEX_MATCH_NOTEMPTY, &match))
-                goto out;
-
-        word = g_match_info_fetch (match, 0);
-        g_debug ("Found command-line match '%s'", word);
-        arg = word + strlen ("gnome.fallback=");
-        if (*arg != '0' && *arg != '1')
-                fprintf (stderr, "gnome-session-is-accelerated: Invalid value '%s' for gnome.fallback passed in kernel command line.\n", arg);
-        else
-                ret = atoi (arg);
-        g_free (word);
-
-out:
-        g_match_info_free (match);
-        g_regex_unref (regex);
-        g_free (contents);
-
-        g_debug ("Command-line parsed to %d", ret);
-
-        return ret;
-}
-#elif defined(__FreeBSD__)
-static int
-_parse_kcmdline (void)
-{
-        int ret = CMDLINE_UNSET;
-        char value[KENV_MVALLEN];
-
-        /* a compile time check to avoid unexpected stack overflow */
-        _Static_assert(KENV_MVALLEN < 1024 * 1024, "KENV_MVALLEN is too large");
-
-        if (kenv (KENV_GET, "gnome.fallback", value, KENV_MVALLEN) == -1)
-                return ret;
-
-        if (*value != '0' && *value != '1')
-                fprintf (stderr, "gnome-session-is-accelerated: Invalid value '%s' for gnome.fallback passed in kernel environment.\n", value);
-        else
-                ret = atoi (value);
-
-        g_debug ("Kernel environment parsed to %d", ret);
-
-        return ret;
-}
-#else
-static int
-_parse_kcmdline (void)
-{
-        return CMDLINE_UNSET;
-}
-#endif
-
-static gboolean
-_has_composite (Display *display)
-{
-        int dummy1, dummy2;
-
-        return XCompositeQueryExtension (display, &dummy1, &dummy2);
-}
-
-static gboolean
-_is_comment (const char *line)
-{
-        while (*line && isspace(*line))
-                line++;
-
-        if (*line == '#' || *line == '\0')
-                return TRUE;
-        return FALSE;
-}
-
-static gboolean
-_is_gl_renderer_blacklisted (const char *renderer)
-{
-        FILE *blacklist;
-        char *line = NULL;
-        size_t line_len = 0;
-        gboolean ret = TRUE;
-
-        blacklist = fopen(PKGDATADIR "/hardware-compatibility", "r");
-        if (blacklist == NULL)
-                goto out;
-
-        while (getline (&line, &line_len, blacklist) != -1) {
-                int whitelist = 0;
-                const char *re_str;
-                regex_t re;
-                int status;
-
-                if (line == NULL)
-                        break;
-
-                /* Drop trailing \n */
-                line[strlen(line) - 1] = '\0';
-
-                if (_is_comment (line)) {
-                        free (line);
-                        line = NULL;
-                        continue;
-                }
-
-                if (line[0] == '+')
-                        whitelist = 1;
-                else if (line[0] == '-')
-                        whitelist = 0;
-                else {
-                        _print_error ("Invalid syntax in this line for hardware compatibility:");
-                        _print_error (line);
-                        free (line);
-                        line = NULL;
-                        continue;
-                }
-
-                re_str = line + 1;
-
-                if (regcomp (&re, re_str, REG_EXTENDED|REG_ICASE|REG_NOSUB) != 0) {
-                        _print_error ("Cannot use this regular expression for hardware compatibility:");
-                        _print_error (re_str);
-                } else {
-                        status = regexec (&re, renderer, 0, NULL, 0);
-                        regfree(&re);
-
-                        if (status == 0) {
-                                if (whitelist)
-                                        ret = FALSE;
-                                goto out;
-                        }
-                }
-
-                free (line);
-                line = NULL;
-        }
-
-        ret = FALSE;
-
-out:
-        if (line != NULL)
-                free (line);
-
-        if (blacklist != NULL)
-                fclose (blacklist);
-
-        return ret;
-}
-
-static char *
-_get_hardware_gl (Display *display)
-{
-        int screen;
-        Window root;
-        XVisualInfo *visual = NULL;
-        GLXContext context = NULL;
-        XSetWindowAttributes cwa = { 0 };
-        Window window = None;
-        char *renderer = NULL;
-
-        int attrlist[] = {
-                GLX_RGBA,
-                GLX_RED_SIZE, 1,
-                GLX_GREEN_SIZE, 1,
-                GLX_BLUE_SIZE, 1,
-                GLX_DOUBLEBUFFER,
-                None
-        };
-
-        screen = DefaultScreen (display);
-        root = RootWindow (display, screen);
-
-        visual = glXChooseVisual (display, screen, attrlist);
-        if (!visual)
-                goto out;
-
-        context = glXCreateContext (display, visual, NULL, True);
-        if (!context)
-                goto out;
-
-        cwa.colormap = XCreateColormap (display, root,
-                                        visual->visual, AllocNone);
-        cwa.background_pixel = 0;
-        cwa.border_pixel = 0;
-        window = XCreateWindow (display, root,
-                                0, 0, 1, 1, 0,
-                                visual->depth, InputOutput, visual->visual,
-                                CWColormap | CWBackPixel | CWBorderPixel,
-                                &cwa);
-
-        if (!glXMakeCurrent (display, window, context))
-                goto out;
-
-        renderer = g_strdup ((const char *) glGetString (GL_RENDERER));
-        if (_is_gl_renderer_blacklisted (renderer)) {
-                g_clear_pointer (&renderer, g_free);
-                goto out;
-        }
-        if (renderer && strcasestr (renderer, "llvmpipe"))
-		has_llvmpipe = TRUE;
-
-        /* we need to get the max texture and renderbuffer sizes while we have
-         * a context, but we'll check their values later */
-
-        glGetIntegerv (GL_MAX_TEXTURE_SIZE, &max_texture_size);
-        if (glGetError() != GL_NO_ERROR)
-                max_texture_size = SIZE_ERROR;
-
-        glGetIntegerv (GL_MAX_RENDERBUFFER_SIZE_EXT, &max_renderbuffer_size);
-        if (glGetError() != GL_NO_ERROR)
-                max_renderbuffer_size = SIZE_ERROR;
-
-out:
-        glXMakeCurrent (display, None, None);
-        if (context)
-                glXDestroyContext (display, context);
-        if (window)
-                XDestroyWindow (display, window);
-        if (cwa.colormap)
-                XFreeColormap (display, cwa.colormap);
-
-        return renderer;
-}
-
-static gboolean
-_has_extension (const char *extension_list,
-                const char *extension)
-{
-        char **extensions;
-        guint i;
-        gboolean ret;
-
-        g_return_val_if_fail (extension != NULL, TRUE);
-
-        /* Extension_list is one big string, containing extensions
-         * separated by spaces. */
-        if (extension_list == NULL)
-                return FALSE;
-
-        ret = FALSE;
-
-        extensions = g_strsplit (extension_list, " ", -1);
-        if (extensions == NULL)
-                return FALSE;
-
-        for (i = 0; extensions[i] != NULL; i++) {
-                if (g_str_equal (extensions[i], extension)) {
-                        ret = TRUE;
-                        break;
-                }
-        }
-
-        g_strfreev (extensions);
-
-        return ret;
-}
-
-static gboolean
-_has_texture_from_pixmap (Display *display)
-{
-        int screen;
-        const char *server_extensions;
-        const char *client_extensions;
-        gboolean ret = FALSE;
-
-        screen = DefaultScreen (display);
-
-        server_extensions = glXQueryServerString (display, screen,
-                                                  GLX_EXTENSIONS);
-        if (!_has_extension (server_extensions,
-                            "GLX_EXT_texture_from_pixmap"))
-                goto out;
-
-        client_extensions = glXGetClientString (display, GLX_EXTENSIONS);
-        if (!_has_extension (client_extensions,
-                            "GLX_EXT_texture_from_pixmap"))
-                goto out;
-
-        ret = TRUE;
-
-out:
-        return ret;
-}
-
-static void
-_set_max_screen_size_property (Display *display, int screen, int size)
-{
-        Atom max_screen_size_atom;
-
-        max_screen_size_atom = XInternAtom (display, "_GNOME_MAX_SCREEN_SIZE",
-                                            False);
-
-        /* Will be read by gnome-settings-daemon and
-         * gnome-control-center to avoid display configurations where 3D
-         * is not available (and would break gnome-shell) */
-        XChangeProperty (display, RootWindow(display, screen),
-                         max_screen_size_atom,
-                         XA_CARDINAL, 32, PropModeReplace,
-                         (unsigned char *)&size, 1);
-
-        XSync(display, False);
-}
-
-static gboolean
-_is_max_texture_size_big_enough (Display *display)
-{
-        int screen, size;
-
-        screen = DefaultScreen (display);
-        size = MIN(max_renderbuffer_size, max_texture_size);
-        if (size < DisplayWidth (display, screen) ||
-            size < DisplayHeight (display, screen))
-                return FALSE;
-
-        _set_max_screen_size_property (display, screen, size);
-
-        return TRUE;
-}
-
-static gboolean print_renderer = FALSE;
-
-static const GOptionEntry entries[] = {
-        { "print-renderer", 'p', 0, G_OPTION_ARG_NONE, &print_renderer, "Print GL renderer name", NULL },
-        { NULL },
-};
-
-int
-main (int argc, char **argv)
-{
-        int             kcmdline_parsed;
-        Display        *display = NULL;
-        int             ret = HELPER_NO_ACCEL;
-        GOptionContext *context;
-        GError         *error = NULL;
-        char           *renderer = NULL;
-
-        setlocale (LC_ALL, "");
-
-        context = g_option_context_new (NULL);
-        g_option_context_add_main_entries (context, entries, NULL);
-
-        if (!g_option_context_parse (context, &argc, &argv, &error)) {
-                g_error ("Can't parse command line: %s\n", error->message);
-                g_error_free (error);
-                goto out;
-        }
-
-        kcmdline_parsed = _parse_kcmdline ();
-        if (kcmdline_parsed > CMDLINE_UNSET) {
-                if (kcmdline_parsed == CMDLINE_NON_FALLBACK_FORCED) {
-                        _print_error ("Non-fallback mode forced by kernel command line.");
-                        ret = HELPER_ACCEL;
-                        goto out;
-                } else if (kcmdline_parsed == CMDLINE_FALLBACK_FORCED) {
-                        _print_error ("Fallback mode forced by kernel command line.");
-                        goto out;
-                }
-        }
-
-        display = XOpenDisplay (NULL);
-        if (!display) {
-                _print_error ("No X display.");
-                goto out;
-        }
-
-        if (!_has_composite (display)) {
-                _print_error ("No composite extension.");
-                goto out;
-        }
-
-        renderer = _get_hardware_gl (display);
-        if (!renderer) {
-                _print_error ("No hardware 3D support.");
-                goto out;
-        }
-
-        if (!_has_texture_from_pixmap (display)) {
-                _print_error ("No GLX_EXT_texture_from_pixmap support.");
-                goto out;
-        }
-
-        if (!_is_max_texture_size_big_enough (display)) {
-                _print_error ("GL_MAX_{TEXTURE,RENDERBUFFER}_SIZE is too small.");
-                goto out;
-        }
-
-        ret = has_llvmpipe ? HELPER_SOFTWARE_RENDERING : HELPER_ACCEL;
-
-        if (print_renderer)
-                g_print ("%s", renderer);
-
-out:
-        if (display)
-                XCloseDisplay (display);
-        g_free (renderer);
-
-        return ret;
-}
diff --git a/tools/gnome-session-check-accelerated-gles-helper.c b/tools/gnome-session-check-accelerated-gles-helper.c
deleted file mode 100644
index 6a4463dbc..000000000
--- a/tools/gnome-session-check-accelerated-gles-helper.c
+++ /dev/null
@@ -1,201 +0,0 @@
-/* -*- mode:c; c-basic-offset: 8; indent-tabs-mode: nil; -*- */
-/*
- *
- * Copyright (C) 2016 Endless Mobile, Inc
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- *
- * Author:
- *   Cosimo Cecchi <cosimo@endlessm.com>
- */
-
-/* for strcasestr */
-#define _GNU_SOURCE
-
-#include <config.h>
-
-#include <gtk/gtk.h>
-#include <locale.h>
-#include <stdlib.h>
-#include <string.h>
-
-#ifdef GDK_WINDOWING_X11
-#define GL_GLEXT_PROTOTYPES
-
-#include <gdk/gdkx.h>
-#include <GLES2/gl2.h>
-#include <GLES2/gl2ext.h>
-#include <EGL/egl.h>
-#endif
-
-#include "gnome-session-check-accelerated-common.h"
-
-#ifdef GDK_WINDOWING_X11
-static char *
-get_gles_renderer (void)
-{
-        /* Select GLESv2 config */
-        EGLint attribs[] = {
-                EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
-                EGL_RED_SIZE, 1,
-                EGL_GREEN_SIZE, 1,
-                EGL_BLUE_SIZE, 1,
-                EGL_NONE
-        };
-
-        EGLint ctx_attribs[] = {
-                EGL_CONTEXT_CLIENT_VERSION, 2,
-                EGL_NONE
-        };
-
-        gboolean egl_inited = FALSE;
-        Display *display;
-        Window win = None;
-        EGLContext egl_ctx = NULL;
-        EGLDisplay egl_dpy = NULL;
-        EGLSurface egl_surf = NULL;
-        char *renderer = NULL;
-
-        gdk_error_trap_push ();
-
-        display = GDK_DISPLAY_XDISPLAY (gdk_display_get_default ());
-        egl_dpy = eglGetDisplay (display);
-        if (!egl_dpy) {
-                g_warning ("eglGetDisplay() failed");
-                goto out;
-        }
-
-        EGLint egl_major, egl_minor;
-        if (!eglInitialize (egl_dpy, &egl_major, &egl_minor)) {
-                g_warning ("eglInitialize() failed");
-                goto out;
-        }
-
-        egl_inited = TRUE;
-
-        EGLint num_configs;
-        EGLConfig config;
-        if (!eglChooseConfig (egl_dpy, attribs, &config, 1, &num_configs)) {
-                g_warning ("Failed to get EGL configuration");
-                goto out;
-        }
-
-        EGLint vid;
-        if (!eglGetConfigAttrib (egl_dpy, config, EGL_NATIVE_VISUAL_ID, &vid)) {
-                g_warning ("Failed to get EGL visual");
-                goto out;
-        }
-
-        /* The X window visual must match the EGL config */
-        XVisualInfo *vis_info, vis_template;
-        int num_visuals;
-        vis_template.visualid = vid;
-        vis_info = XGetVisualInfo (display, VisualIDMask, &vis_template, &num_visuals);
-        if (!vis_info) {
-                g_warning ("Failed to get X visual");
-                goto out;
-        }
-
-        XSetWindowAttributes attr;
-        attr.colormap = XCreateColormap (display, DefaultRootWindow (display),
-                                         vis_info->visual, AllocNone);
-        win = XCreateWindow (display, DefaultRootWindow (display),
-                             0, 0, /* x, y */
-                             1, 1, /* width, height */
-                             0,    /* border_width */
-                             vis_info->depth, InputOutput,
-                             vis_info->visual, CWColormap, &attr);
-        XFree (vis_info);
-
-        eglBindAPI (EGL_OPENGL_ES_API);
-
-        egl_ctx = eglCreateContext (egl_dpy, config, EGL_NO_CONTEXT, ctx_attribs);
-        if (!egl_ctx) {
-                g_warning ("Failed to create EGL context");
-                goto out;
-        }
-
-        egl_surf = eglCreateWindowSurface (egl_dpy, config, win, NULL);
-        if (!egl_surf) {
-                g_warning ("Failed to create EGL surface");
-                goto out;
-        }
-
-        if (!eglMakeCurrent (egl_dpy, egl_surf, egl_surf, egl_ctx)) {
-                g_warning ("eglMakeCurrent() failed");
-                goto out;
-        }
-
-        renderer = g_strdup ((const char *) glGetString (GL_RENDERER));
-
- out:
-        if (egl_ctx)
-                eglDestroyContext (egl_dpy, egl_ctx);
-        if (egl_surf)
-                eglDestroySurface (egl_dpy, egl_surf);
-        if (egl_inited)
-                eglTerminate (egl_dpy);
-        if (win != None)
-                XDestroyWindow (display, win);
-
-        gdk_error_trap_pop_ignored ();
-        return renderer;
-}
-#endif
-
-static gboolean print_renderer = FALSE;
-
-static const GOptionEntry entries[] = {
-        { "print-renderer", 'p', 0, G_OPTION_ARG_NONE, &print_renderer, "Print EGL renderer name", NULL },
-        { NULL },
-};
-
-int
-main (int argc,
-      char **argv)
-{
-        char *renderer = NULL;
-        GOptionContext *context;
-        int ret = HELPER_NO_ACCEL;
-        GError *error = NULL;
-
-        setlocale (LC_ALL, "");
-
-        context = g_option_context_new (NULL);
-        g_option_context_add_group (context, gtk_get_option_group (TRUE));
-        g_option_context_add_main_entries (context, entries, NULL);
-
-        if (!g_option_context_parse (context, &argc, &argv, &error)) {
-                g_error ("Can't parse command line: %s\n", error->message);
-                g_error_free (error);
-                goto out;
-        }
-
-#ifdef GDK_WINDOWING_X11
-        renderer = get_gles_renderer ();
-#endif
-
-        if (renderer != NULL) {
-                if (print_renderer)
-                        g_print ("%s", renderer);
-                if (strcasestr (renderer, "llvmpipe"))
-                        ret = HELPER_SOFTWARE_RENDERING;
-                else
-                        ret = HELPER_ACCEL;
-        }
-
-out:
-        return ret;
-}
diff --git a/tools/gnome-session-check-accelerated.c b/tools/gnome-session-check-accelerated.c
deleted file mode 100644
index 3765f521f..000000000
--- a/tools/gnome-session-check-accelerated.c
+++ /dev/null
@@ -1,318 +0,0 @@
-/* -*- mode:c; c-basic-offset: 8; indent-tabs-mode: nil; -*- */
-/* Tool to set the property _GNOME_SESSION_ACCELERATED on the root window */
-/*
- * Copyright (C) 2011 Red Hat, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * Author:
- *   Colin Walters <walters@verbum.org>
- */
-
-#include <string.h>
-#include <unistd.h>
-#include <stdlib.h>
-
-#include <gtk/gtk.h>
-#include <epoxy/gl.h>
-#include <gdk/gdkx.h>
-#include <X11/Xatom.h>
-#include <sys/wait.h>
-
-#include "gnome-session-check-accelerated-common.h"
-
-/* Wait up to this long for a running check to finish */
-#define PROPERTY_CHANGE_TIMEOUT 5000
-
-/* Values used for the _GNOME_SESSION_ACCELERATED root window property */
-#define NO_ACCEL            0
-#define HAVE_ACCEL          1
-#define ACCEL_CHECK_RUNNING 2
-
-static Atom is_accelerated_atom;
-static Atom is_software_rendering_atom;
-static Atom renderer_atom;
-static gboolean property_changed;
-
-static gboolean
-on_property_notify_timeout (gpointer data)
-{
-        gtk_main_quit ();
-        return FALSE;
-}
-
-static GdkFilterReturn
-property_notify_filter (GdkXEvent *xevent,
-                        GdkEvent  *event,
-                        gpointer   data)
-{
-        XPropertyEvent *ev = xevent;
-
-        if (ev->type == PropertyNotify && ev->atom == is_accelerated_atom) {
-                property_changed = TRUE;
-                gtk_main_quit ();
-        }
-
-        return GDK_FILTER_CONTINUE;
-}
-
-static gboolean
-wait_for_property_notify (void)
-{
-        GdkDisplay *display;
-        GdkScreen *screen;
-        GdkWindow *root;
-        Window rootwin;
-
-        property_changed = FALSE;
-
-        display = gdk_display_get_default ();
-        screen = gdk_display_get_default_screen (display);
-        root = gdk_screen_get_root_window (screen);
-        rootwin = gdk_x11_window_get_xid (root);
-
-        XSelectInput (GDK_DISPLAY_XDISPLAY (display), rootwin, PropertyChangeMask);
-        gdk_window_add_filter (root, property_notify_filter, NULL);
-        g_timeout_add (PROPERTY_CHANGE_TIMEOUT, on_property_notify_timeout, NULL);
-
-        gtk_main ();
-
-        return property_changed;
-}
-
-static char *
-get_gtk_gles_renderer (GError **error)
-{
-        GtkWidget *win;
-        GdkGLContext *context;
-        char *renderer = NULL;
-
-        win = gtk_window_new (GTK_WINDOW_TOPLEVEL);
-        gtk_widget_realize (win);
-        context = gdk_window_create_gl_context (gtk_widget_get_window (win), error);
-        if (!context)
-                return NULL;
-        gdk_gl_context_make_current (context);
-        renderer = g_strdup ((char *) glGetString (GL_RENDERER));
-        gdk_gl_context_clear_current ();
-        g_object_unref (context);
-
-        return renderer;
-}
-
-static gboolean
-is_discrete_gpu_check (void)
-{
-	const char *dri_prime;
-
-	dri_prime = g_getenv ("DRI_PRIME");
-	if (!dri_prime)
-		return FALSE;
-	if (*dri_prime != '1')
-		return FALSE;
-	return TRUE;
-}
-
-int
-main (int argc, char **argv)
-{
-        GdkDisplay *display = NULL;
-        int estatus;
-        char *gl_helper_argv[] = { LIBEXECDIR "/gnome-session-check-accelerated-gl-helper", "--print-renderer", NULL };
-        char *gles_helper_argv[] = { LIBEXECDIR "/gnome-session-check-accelerated-gles-helper", "--print-renderer", NULL };
-        const char *renderer_string = NULL;
-        char *gl_renderer_string = NULL, *gles_renderer_string = NULL;
-        gboolean gl_software_rendering = FALSE, gles_software_rendering = FALSE;
-        Window rootwin;
-        glong is_accelerated, is_software_rendering;
-        GError *gl_error = NULL, *gles_error = NULL, *gtk_gles_error = NULL;
-
-        gtk_init (NULL, NULL);
-
-        /* gnome-session-check-accelerated gets run before X is started in the wayland
-         * case, and it currently requires X. Until we have that working, just always
-         * assume wayland will work.
-         * Also make sure that we don't read cached information about the first GPU
-         * when requesting information about the second.
-         */
-        if (is_discrete_gpu_check () || g_strcmp0 (g_getenv ("XDG_SESSION_TYPE"), "x11") != 0) {
-                g_autofree char *discrete_renderer_string = get_gtk_gles_renderer (&gtk_gles_error);
-                if (discrete_renderer_string) {
-                        g_print ("%s", discrete_renderer_string);
-                        return 0;
-                }
-                if (gtk_gles_error != NULL) {
-                        g_printerr ("gnome-session-check-accelerated: "
-                                    "Failed to get GTK GLES renderer: %s\n",
-                                    gtk_gles_error->message);
-                        g_clear_error (&gtk_gles_error);
-                }
-                return 1;
-        }
-
-        display = gdk_display_get_default ();
-        /* when running on X11 with a nested wayland GDK will default to wayland
-         * so looking for X11 atoms will not work (and crash).
-         */
-        if (!GDK_IS_X11_DISPLAY (display)) {
-                g_printerr ("gnome-session-check-accelerated: no X11 display found\n");
-                return 1;
-        }
-
-        rootwin = gdk_x11_get_default_root_xwindow ();
-
-        is_accelerated_atom = gdk_x11_get_xatom_by_name_for_display (display, "_GNOME_SESSION_ACCELERATED");
-        is_software_rendering_atom = gdk_x11_get_xatom_by_name_for_display (display, "_GNOME_IS_SOFTWARE_RENDERING");
-        renderer_atom = gdk_x11_get_xatom_by_name_for_display (display, "_GNOME_SESSION_RENDERER");
-
-        {
-                Atom type;
-                gint format;
-                gulong nitems;
-                gulong bytes_after;
-                guchar *data;
-
- read:
-                gdk_x11_display_error_trap_push (display);
-                XGetWindowProperty (GDK_DISPLAY_XDISPLAY (display), rootwin,
-                                    is_accelerated_atom,
-                                    0, G_MAXLONG, False, XA_CARDINAL, &type, &format, &nitems,
-                                    &bytes_after, &data);
-                gdk_x11_display_error_trap_pop_ignored (display);
-
-                if (type == XA_CARDINAL) {
-                        glong *is_accelerated_ptr = (glong*) data;
-
-                        if (*is_accelerated_ptr == ACCEL_CHECK_RUNNING) {
-                                /* Test in progress, wait */
-                                if (wait_for_property_notify ())
-                                        goto read;
-                                /* else fall through and do the check ourselves */
-
-                        } else {
-                                gdk_x11_display_error_trap_push (display);
-                                XGetWindowProperty (GDK_DISPLAY_XDISPLAY (display), rootwin,
-                                                    renderer_atom,
-                                                    0, G_MAXLONG, False, XA_STRING, &type, &format, &nitems,
-                                                    &bytes_after, &data);
-                                gdk_x11_display_error_trap_pop_ignored (display);
-
-                                if (type == XA_STRING) {
-                                        g_print ("%s", data);
-                                }
-
-                                return (*is_accelerated_ptr == 0 ? 1 : 0);
-                        }
-                }
-        }
-
-        /* We don't have the property or it's the wrong type.
-         * Try to compute it now.
-         */
-
-        /* First indicate that a test is in progress */
-        is_accelerated = ACCEL_CHECK_RUNNING;
-        is_software_rendering = FALSE;
-        estatus = 1;
-
-        XChangeProperty (GDK_DISPLAY_XDISPLAY (display),
-                         rootwin,
-                         is_accelerated_atom,
-                         XA_CARDINAL, 32, PropModeReplace, (guchar *) &is_accelerated, 1);
-
-        gdk_display_sync (display);
-
-        /* First, try the GL helper */
-        if (g_spawn_sync (NULL, (char **) gl_helper_argv, NULL, 0,
-                           NULL, NULL, &gl_renderer_string, NULL, &estatus, &gl_error)) {
-                is_accelerated = (WEXITSTATUS(estatus) == HELPER_ACCEL);
-                gl_software_rendering = (WEXITSTATUS(estatus) == HELPER_SOFTWARE_RENDERING);
-                if (is_accelerated) {
-                        renderer_string = gl_renderer_string;
-                        goto finish;
-                }
-
-                g_printerr ("gnome-session-check-accelerated: GL Helper exited with code %d\n", estatus);
-        }
-
-        /* Then, try the GLES helper */
-        if (g_spawn_sync (NULL, (char **) gles_helper_argv, NULL, 0,
-                           NULL, NULL, &gles_renderer_string, NULL, &estatus, &gles_error)) {
-                is_accelerated = (WEXITSTATUS(estatus) == HELPER_ACCEL);
-                gles_software_rendering = (WEXITSTATUS(estatus) == HELPER_SOFTWARE_RENDERING);
-                if (is_accelerated) {
-                        renderer_string = gles_renderer_string;
-                        goto finish;
-                }
-
-                g_printerr ("gnome-session-check-accelerated: GLES Helper exited with code %d\n", estatus);
-        }
-
-        /* If we got here, GL software rendering is our best bet */
-        if (gl_software_rendering || gles_software_rendering) {
-                is_software_rendering = TRUE;
-                is_accelerated = TRUE;
-
-                if (gl_software_rendering)
-                        renderer_string = gl_renderer_string;
-                else if (gles_software_rendering)
-                        renderer_string = gles_renderer_string;
-
-                goto finish;
-        }
-
-        /* Both helpers failed; print their error messages */
-        if (gl_error != NULL) {
-                g_printerr ("gnome-session-check-accelerated: Failed to run GL helper: %s\n", gl_error->message);
-                g_clear_error (&gl_error);
-        }
-
-        if (gles_error != NULL) {
-                g_printerr ("gnome-session-check-accelerated: Failed to run GLES helper: %s\n", gles_error->message);
-                g_clear_error (&gles_error);
-        }
-
- finish:
-	if (is_accelerated) {
-		XChangeProperty (GDK_DISPLAY_XDISPLAY (display),
-				rootwin,
-				is_accelerated_atom,
-				XA_CARDINAL, 32, PropModeReplace, (guchar *) &is_accelerated, 1);
-	}
-
-	if (is_software_rendering) {
-		XChangeProperty (GDK_DISPLAY_XDISPLAY (display),
-				rootwin,
-				is_software_rendering_atom,
-				XA_CARDINAL, 32, PropModeReplace, (guchar *) &is_software_rendering, 1);
-	}
-
-        if (renderer_string != NULL) {
-                XChangeProperty (GDK_DISPLAY_XDISPLAY (display),
-				rootwin,
-				renderer_atom,
-				XA_STRING, 8, PropModeReplace, (guchar *) renderer_string, strlen (renderer_string));
-
-                /* Print the renderer */
-                g_print ("%s", renderer_string);
-        }
-
-        gdk_display_sync (display);
-
-        g_free (gl_renderer_string);
-        g_free (gles_renderer_string);
-
-        return is_accelerated ? 0 : 1;
-}
diff --git a/tools/gnome-session-custom-session b/tools/gnome-session-custom-session
deleted file mode 100755
index 07fdb0ccc..000000000
--- a/tools/gnome-session-custom-session
+++ /dev/null
@@ -1,4 +0,0 @@
-#! /bin/sh
-
-gnome-session-selector
-exec gnome-session
diff --git a/tools/gnome-session-selector.c b/tools/gnome-session-selector.c
deleted file mode 100644
index 71892c43d..000000000
--- a/tools/gnome-session-selector.c
+++ /dev/null
@@ -1,698 +0,0 @@
-/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
- *
- * Copyright 2010, 2013  Red Hat, Inc,
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, see <http://www.gnu.org/licenses/>.
- *
- * Written by: Matthias Clasen <mclasen@redhat.com>
- */
-
-#include "config.h"
-
-#include <fcntl.h>
-#include <stdlib.h>
-#include <string.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <unistd.h>
-
-#include <glib.h>
-#include <gtk/gtk.h>
-#include <gio/gio.h>
-
-#include <glib/gi18n.h>
-#include <glib/gstdio.h>
-
-#define GSM_MANAGER_SCHEMA        "org.gnome.SessionManager"
-#define KEY_AUTOSAVE_ONE_SHOT     "auto-save-session-one-shot"
-
-static GtkBuilder *builder;
-static GtkWidget *session_list;
-static GtkListStore *store;
-static GtkTreeModelSort *sort_model;
-
-static void select_session (const char *name);
-
-static char *
-get_session_path (const char *name)
-{
-        return g_build_filename (g_get_user_config_dir (), "gnome-session", name, NULL);
-}
-
-static char *
-find_new_session_name (void)
-{
-        char *name;
-        char *path;
-        int i;
-
-        for (i = 1; i < 20; i++) {
-                name = g_strdup_printf (_("Session %d"), i);
-                path = get_session_path (name);
-                if (!g_file_test (path, G_FILE_TEST_EXISTS)) {
-                        g_free (path);
-                        return name;
-                }
-                g_free (path);
-                g_free (name);
-        }
-
-        return NULL;
-}
-
-static gboolean
-is_valid_session_name (const char *name)
-{
-        GtkTreeIter iter;
-        char *n;
-        const char *info_text;
-        char *warning_text;
-        gboolean user_tried_dot;
-        gboolean user_tried_slash;
-        GtkWidget *info_bar;
-        GtkWidget *label;
-
-        if (name[0] == 0) {
-                return FALSE;
-        }
-
-        if (name[0] == '.') {
-            user_tried_dot = TRUE;
-        } else {
-            user_tried_dot = FALSE;
-        }
-
-        if (strchr (name, '/') != NULL) {
-            user_tried_slash = TRUE;
-        } else {
-            user_tried_slash = FALSE;
-        }
-
-        info_text = _("Please select a custom session to run");
-        warning_text = NULL;
-        if (user_tried_dot && user_tried_slash) {
-            warning_text = g_strdup_printf ("%s\n<small><b>Note:</b> <i>%s</i></small>",
-                                            info_text,
-                                            _("Session names are not allowed to start with â€œ.â€ or contain â€œ/â€ characters"));
-        } else if (user_tried_dot) {
-            warning_text = g_strdup_printf ("%s\n<small><b>Note:</b> <i>%s</i></small>",
-                                            info_text,
-                                            _("Session names are not allowed to start with â€œ.â€"));
-        } else if (user_tried_slash) {
-            warning_text = g_strdup_printf ("%s\n<small><b>Note:</b> <i>%s</i></small>",
-                                            info_text,
-                                            _("Session names are not allowed to contain â€œ/â€ characters"));
-        }
-
-        gtk_tree_model_get_iter_first (GTK_TREE_MODEL (store), &iter);
-        do {
-                gtk_tree_model_get (GTK_TREE_MODEL (store), &iter, 0, &n, -1);
-                if (strcmp (n, name) == 0) {
-                        char *message;
-                        message = g_strdup_printf (_("A session named â€œ%sâ€ already exists"), name);
-                        warning_text = g_strdup_printf ("%s\n<small><b>Note:</b> <i>%s</i></small>", info_text, message);
-                        g_free (message);
-                        g_free (n);
-                        break;
-                }
-                g_free (n);
-        } while (gtk_tree_model_iter_next (GTK_TREE_MODEL (store), &iter));
-
-        info_bar = (GtkWidget *) gtk_builder_get_object (builder, "info-bar");
-        label = (GtkWidget*) gtk_builder_get_object (builder, "info-label");
-
-        if (warning_text != NULL) {
-            gtk_info_bar_set_message_type (GTK_INFO_BAR (info_bar), GTK_MESSAGE_WARNING);
-            gtk_label_set_markup (GTK_LABEL (label), warning_text);
-            g_free (warning_text);
-            return FALSE;
-        }
-
-        gtk_info_bar_set_message_type (GTK_INFO_BAR (info_bar), GTK_MESSAGE_OTHER);
-        gtk_label_set_markup (GTK_LABEL (label), info_text);
-
-        return TRUE;
-}
-
-static void
-populate_session_list (GtkWidget *session_list)
-{
-        GtkTreeIter iter;
-        char *path;
-        const char *name;
-        GDir *dir;
-        GError *error;
-        char *saved_session;
-        char *default_session;
-        char *default_name;
-        char last_session[PATH_MAX] = "";
-
-        saved_session = get_session_path ("saved-session");
-
-        if (!g_file_test (saved_session, G_FILE_TEST_IS_SYMLINK)) {
-                default_name = find_new_session_name ();
-                default_session = get_session_path (default_name);
-                rename (saved_session, default_session);
-                if (symlink (default_name, saved_session) < 0)
-                        g_warning ("Failed to convert saved-session to symlink");
-                g_free (default_name);
-                g_free (default_session);
-        }
-
-        path = g_build_filename (g_get_user_config_dir (), "gnome-session", NULL);
-        error = NULL;
-        dir = g_dir_open (path, 0, &error);
-        if (dir == NULL) {
-                g_warning ("Failed to open %s: %s", path, error->message);
-                g_error_free (error);
-                goto out;
-        }
-
-        default_name = NULL;
-        if (readlink (saved_session, last_session, PATH_MAX - 1) > 0) {
-                default_name = g_path_get_basename (last_session);
-        }
-
-        while ((name = g_dir_read_name (dir)) != NULL) {
-                if (strcmp (name, "saved-session") == 0)
-                        continue;
-
-                gtk_list_store_insert_with_values (store, &iter, 100, 0, name, -1);
-
-                if (g_strcmp0 (default_name, name) == 0) {
-                        GtkTreeSelection *selection;
-                        GtkTreeIter child_iter;
-
-                        gtk_tree_model_sort_convert_child_iter_to_iter (GTK_TREE_MODEL_SORT (sort_model), &child_iter, &iter);
-                        selection = gtk_tree_view_get_selection (GTK_TREE_VIEW (session_list));
-                        gtk_tree_selection_select_iter (selection, &child_iter);
-                }
-        }
-
-        g_free (default_name);
-        g_dir_close (dir);
-
- out:
-        g_free (saved_session);
-        g_free (path);
-}
-
-static char *
-get_selected_session (void)
-{
-        GtkTreeSelection *selection;
-        GtkTreeModel *model;
-        GtkTreeIter iter;
-        gchar *name;
-
-        selection = gtk_tree_view_get_selection (GTK_TREE_VIEW (session_list));
-        if (gtk_tree_selection_get_selected (selection, &model, &iter)) {
-                gtk_tree_model_get (model, &iter, 0, &name, -1);
-                return name;
-        }
-
-        return NULL;
-}
-
-static void
-remove_session (const char *name)
-{
-        char *path1, *path2;
-        char *n, *path;
-        const char *d;
-        GDir *dir;
-        GError *error;
-
-        path1 = get_session_path ("saved-session");
-        path2 = get_session_path (name);
-
-        error = NULL;
-        n = g_file_read_link (path1, &error);
-        if (n == NULL) {
-                g_warning ("Failed to read link: %s", error->message);
-                g_error_free (error);
-        }
-        else if (strcmp (n, name) == 0) {
-                unlink (path1);
-        }
-        g_free (n);
-
-        dir = g_dir_open (path2, 0, NULL);
-        while ((d = g_dir_read_name (dir)) != NULL) {
-                path = g_build_filename (path2, d, NULL);
-                unlink (path);
-                g_free (path);
-        }
-        g_dir_close (dir);
-
-        remove (path2);
-
-        g_free (path1);
-        g_free (path2);
-}
-
-static void
-on_remove_session_clicked (GtkButton *button,
-                           gpointer   data)
-{
-        GtkTreeSelection *selection;
-        GtkTreeModel *model;
-        GtkTreeIter iter;
-        char *name;
-
-        selection = gtk_tree_view_get_selection (GTK_TREE_VIEW (session_list));
-        if (gtk_tree_selection_get_selected (selection, &model, &iter)) {
-                GtkTreeIter child_iter;
-                gtk_tree_model_get (model, &iter, 0, &name, -1);
-                remove_session (name);
-                g_free (name);
-
-                gtk_tree_model_sort_convert_iter_to_child_iter (GTK_TREE_MODEL_SORT (model), &child_iter, &iter);
-                gtk_list_store_remove (GTK_LIST_STORE (store), &child_iter);
-
-                if (!gtk_tree_selection_get_selected (selection, NULL, NULL)) {
-                        gtk_tree_model_get_iter_first (model, &iter);
-                        gtk_tree_model_get (model, &iter, 0, &name, -1);
-                        select_session (name);
-                        g_free (name);
-                }
-        }
-}
-
-static void
-begin_rename (void)
-{
-        GtkTreePath *path;
-        GtkTreeViewColumn *column;
-        GList *cells;
-
-        gtk_widget_grab_focus (session_list);
-
-        gtk_tree_view_get_cursor (GTK_TREE_VIEW (session_list),
-                                  &path, &column);
-
-        cells = gtk_cell_layout_get_cells (GTK_CELL_LAYOUT (column));
-
-        if (cells != NULL) {
-            GtkCellRenderer *cell;
-
-            cell = (GtkCellRenderer *) cells->data;
-            g_list_free (cells);
-
-            g_object_set (cell, "editable", TRUE, NULL);
-            gtk_tree_view_set_cursor_on_cell (GTK_TREE_VIEW (session_list), path,
-                                              column, cell, TRUE);
-        }
-        gtk_tree_path_free (path);
-}
-
-static void
-on_rename_session_clicked (GtkButton *button,
-                           gpointer   data)
-{
-    begin_rename ();
-}
-
-static void
-on_continue_clicked (GtkButton *button,
-                     gpointer    data)
-{
-        char *name;
-
-        name = get_selected_session ();
-        g_free (name);
-
-        gtk_main_quit ();
-}
-
-static void
-create_session (const char *name)
-{
-        char *path;
-        GtkTreeIter iter;
-
-        path = get_session_path (name);
-
-        if (mkdir (path, 0755) < 0) {
-                g_warning ("Failed to create directory %s", path);
-        }
-        else {
-                char *marker;
-
-                gtk_list_store_insert_with_values (store, &iter, 100, 0, name, -1);
-
-                marker = g_build_filename (path, ".new-session", NULL);
-                creat (marker, 0600);
-                g_free (marker);
-        }
-
-        g_free (path);
-}
-
-static gboolean
-rename_session (const char *old_name,
-                const char *new_name)
-{
-        char *old_path, *new_path;
-        int result;
-
-        if (g_strcmp0 (old_name, new_name) == 0) {
-                return TRUE;
-        }
-
-        if (!is_valid_session_name (new_name)) {
-               return FALSE;
-        }
-
-        old_path = get_session_path (old_name);
-        new_path = get_session_path (new_name);
-
-        result = g_rename (old_path, new_path);
-
-        if (result < 0) {
-                g_warning ("Failed to rename session from '%s' to '%s': %m", old_name, new_name);
-        }
-
-        g_free (old_path);
-        g_free (new_path);
-
-        return result == 0;
-}
-
-static gboolean
-make_session_current (const char *name)
-{
-        char *path1;
-        gboolean ret = TRUE;
-
-        path1 = g_build_filename (g_get_user_config_dir (), "gnome-session", "saved-session", NULL);
-
-        unlink (path1);
-        if (symlink (name, path1) < 0) {
-                g_warning ("Failed to make session '%s' current", name);
-                ret = FALSE;
-        }
-
-        g_free (path1);
-
-        return ret;
-}
-
-static gboolean
-create_and_select_session (const char *name)
-{
-        gchar *path;
-
-        if (name[0] == 0 || name[0] == '.' || strchr (name, '/')) {
-                g_warning ("Invalid session name");
-                return FALSE;
-        }
-
-        path = g_build_filename (g_get_user_config_dir (), "gnome-session", name, NULL);
-        if (!g_file_test (path, G_FILE_TEST_IS_DIR)) {
-                if (mkdir (path, 0755) < 0) {
-                        g_warning ("Failed to create directory %s", path);
-                        g_free (path);
-                        return FALSE;
-                }
-        }
-
-        g_free (path);
-
-        return make_session_current (name);
-}
-
-static void
-select_session (const char *name)
-{
-        GtkTreeIter iter;
-        char *n;
-
-        make_session_current (name);
-
-        /* now select it in the list */
-        gtk_tree_model_get_iter_first (GTK_TREE_MODEL (sort_model), &iter);
-        do {
-                gtk_tree_model_get (GTK_TREE_MODEL (sort_model), &iter, 0, &n, -1);
-                if (strcmp (n, name) == 0) {
-                        GtkTreePath *path;
-
-                        path = gtk_tree_model_get_path (GTK_TREE_MODEL (sort_model), &iter);
-                        gtk_tree_view_set_cursor (GTK_TREE_VIEW (session_list), path, NULL, FALSE);
-                        gtk_tree_path_free (path);
-                        g_free (n);
-                        break;
-                }
-                g_free (n);
-        } while (gtk_tree_model_iter_next (GTK_TREE_MODEL (sort_model), &iter));
-}
-
-static void
-on_new_session_clicked (GtkButton *button,
-                        gpointer   data)
-{
-        gchar *name;
-
-        name = find_new_session_name ();
-        create_session (name);
-        select_session (name);
-
-        begin_rename ();
-}
-
-static void
-on_selection_changed (GtkTreeSelection *selection,
-                      gpointer          data)
-{
-        char *name;
-
-        name = get_selected_session ();
-
-        if (name == NULL) {
-                return;
-        }
-
-        make_session_current (name);
-
-        g_free (name);
-}
-
-static void
-update_remove_button (void)
-{
-        GtkWidget *button;
-
-        button = (GtkWidget *)gtk_builder_get_object (builder, "remove-session");
-        if (gtk_tree_model_iter_n_children (GTK_TREE_MODEL (store), NULL) > 1) {
-                gtk_widget_set_sensitive (button, TRUE);
-        } else {
-                gtk_widget_set_sensitive (button, FALSE);
-        }
-}
-
-static void
-on_row_edited (GtkCellRendererText *cell,
-               const char          *path_string,
-               const char          *new_name,
-               gpointer             data)
-{
-        GtkTreePath *path;
-        GtkTreeIter  sort_iter, items_iter;
-        char        *old_name;
-        gboolean     was_renamed;
-
-        path = gtk_tree_path_new_from_string (path_string);
-        gtk_tree_model_get_iter (GTK_TREE_MODEL (sort_model), &sort_iter, path);
-
-        gtk_tree_model_get (GTK_TREE_MODEL (sort_model), &sort_iter, 0, &old_name, -1);
-
-        was_renamed = rename_session (old_name, new_name);
-
-        if (was_renamed) {
-                gtk_tree_model_sort_convert_iter_to_child_iter (sort_model, &items_iter, &sort_iter);
-
-                gtk_list_store_set (store, &items_iter, 0, g_strdup (new_name), -1);
-                g_free (old_name);
-                make_session_current (new_name);
-        } else {
-                begin_rename ();
-        }
-
-        gtk_tree_path_free (path);
-
-        g_object_set (cell, "editable", FALSE, NULL);
-}
-
-static void
-on_row_deleted (GtkTreeModel *model,
-                GtkTreePath  *path,
-                gpointer      data)
-{
-        update_remove_button ();
-}
-
-static void
-on_row_inserted (GtkTreeModel *model,
-                 GtkTreePath  *path,
-                 GtkTreeIter  *iter,
-                 gpointer      data)
-{
-        update_remove_button ();
-}
-
-static void
-on_row_activated (GtkTreeView       *tree_view,
-                  GtkTreePath       *path,
-                  GtkTreeViewColumn *column,
-                  gpointer           data)
-{
-        char *name;
-
-        name = get_selected_session ();
-        g_free (name);
-
-        gtk_main_quit ();
-}
-
-static void
-auto_save_next_session (void)
-{
-        GSettings *settings;
-
-        settings = g_settings_new (GSM_MANAGER_SCHEMA);
-        g_settings_set_boolean (settings, KEY_AUTOSAVE_ONE_SHOT, TRUE);
-        g_object_unref (settings);
-}
-
-static void
-auto_save_next_session_if_needed (void)
-{
-        char *marker;
-
-        marker = g_build_filename (g_get_user_config_dir (),
-                                   "gnome-session", "saved-session",
-                                   ".new-session", NULL);
-
-        if (g_file_test (marker, G_FILE_TEST_EXISTS)) {
-                auto_save_next_session ();
-                unlink (marker);
-        }
-        g_free (marker);
-}
-
-static int
-compare_sessions (GtkTreeModel *model,
-                  GtkTreeIter  *a,
-                  GtkTreeIter  *b,
-                  gpointer      data)
-{
-    char *name_a, *name_b;
-    int result;
-
-    gtk_tree_model_get (model, a, 0, &name_a, -1);
-    gtk_tree_model_get (model, b, 0, &name_b, -1);
-
-    result = g_utf8_collate (name_a, name_b);
-
-    g_free (name_a);
-    g_free (name_b);
-
-    return result;
-}
-
-static void
-on_map (GtkWidget *widget,
-        gpointer   data)
-{
-        gdk_window_focus (gtk_widget_get_window (widget), GDK_CURRENT_TIME);
-}
-
-int
-main (int argc, char *argv[])
-{
-        GtkWidget *window;
-        GtkWidget *widget;
-        GtkCellRenderer *cell;
-        GtkTreeViewColumn *column;
-        GtkTreeSelection *selection;
-        GError *error;
-
-        if (getenv ("SESSION_MANAGER") != NULL)
-            return 1;
-
-        gtk_init (&argc, &argv);
-        if (argc > 1) {
-                g_print ("create and select session\n");
-                if (!create_and_select_session (argv[1]))
-                        return 1;
-                else
-                        return 0;
-        }
-
-        builder = gtk_builder_new ();
-        gtk_builder_set_translation_domain (builder, GETTEXT_PACKAGE);
-
-        error = NULL;
-        if (!gtk_builder_add_from_file (builder, GTKBUILDER_DIR "/" "session-selector.ui",  &error)) {
-                g_warning ("Could not load file 'session-selector.ui': %s", error->message);
-                exit (1);
-        }
-
-        window = (GtkWidget *) gtk_builder_get_object (builder, "main-window");
-
-        store = (GtkListStore *) gtk_builder_get_object (builder, "session-store");
-        sort_model = (GtkTreeModelSort *) gtk_builder_get_object (builder, "sort-model");
-
-        gtk_tree_sortable_set_sort_func (GTK_TREE_SORTABLE (sort_model),
-                                         0, compare_sessions, NULL, NULL);
-        gtk_tree_sortable_set_sort_column_id (GTK_TREE_SORTABLE (sort_model),
-                                              0, GTK_SORT_ASCENDING);
-        g_signal_connect (store, "row-deleted", G_CALLBACK (on_row_deleted), NULL);
-        g_signal_connect (store, "row-inserted", G_CALLBACK (on_row_inserted), NULL);
-        session_list = (GtkWidget *) gtk_builder_get_object (builder, "session-list");
-
-        selection = gtk_tree_view_get_selection (GTK_TREE_VIEW (session_list));
-        gtk_tree_selection_set_mode (selection, GTK_SELECTION_SINGLE);
-
-        populate_session_list (session_list);
-
-        cell = gtk_cell_renderer_text_new ();
-        g_signal_connect (cell, "edited", G_CALLBACK (on_row_edited), NULL);
-
-        column = gtk_tree_view_column_new_with_attributes ("", cell, "text", 0, NULL);
-        gtk_tree_view_append_column (GTK_TREE_VIEW (session_list), GTK_TREE_VIEW_COLUMN (column));
-
-        g_signal_connect (session_list, "row-activated", G_CALLBACK (on_row_activated), NULL);
-
-        g_signal_connect (selection, "changed",
-                          G_CALLBACK (on_selection_changed), NULL);
-
-        widget = (GtkWidget *) gtk_builder_get_object (builder, "new-session");
-        g_signal_connect (widget, "clicked", G_CALLBACK (on_new_session_clicked), NULL);
-        widget = (GtkWidget *) gtk_builder_get_object (builder, "remove-session");
-        g_signal_connect (widget, "clicked", G_CALLBACK (on_remove_session_clicked), NULL);
-        widget = (GtkWidget *) gtk_builder_get_object (builder, "rename-session");
-        g_signal_connect (widget, "clicked", G_CALLBACK (on_rename_session_clicked), NULL);
-        widget = (GtkWidget *) gtk_builder_get_object (builder, "continue-button");
-        g_signal_connect (widget, "clicked", G_CALLBACK (on_continue_clicked), NULL);
-
-        g_signal_connect (window, "map", G_CALLBACK (on_map), NULL);
-        gtk_widget_show (window);
-
-        gtk_main ();
-
-        auto_save_next_session_if_needed ();
-
-        return 0;
-}
diff --git a/tools/meson.build b/tools/meson.build
index 6ea37b621..72794d452 100644
--- a/tools/meson.build
+++ b/tools/meson.build
@@ -1,61 +1,13 @@
-deps = session_deps + [
-  sm_dep,
-  ice_dep
-]
-
 cflags = ['-DLOCALE_DIR="@0@"'.format(session_localedir)]
 
 programs = [
   # name, deps, cflags, install_dir
-  ['gnome-session-quit', deps, cflags, session_bindir],
+  ['gnome-session-quit', session_deps, cflags, session_bindir],
   ['gnome-session-inhibit', session_deps, cflags, session_bindir]
 ]
 
 programs += [['gnome-session-ctl', session_bin_deps, cflags, session_libexecdir]]
 
-if enable_session_selector
-  deps = [
-    glib_dep,
-    gtk_dep
-  ]
-
-  install_data(
-    'gnome-session-custom-session',
-    install_dir: session_bindir
-  )
-
-  cflags += '-DGTKBUILDER_DIR="@0@"'.format(session_pkgdatadir)
-
-  programs += [['gnome-session-selector', deps, cflags, session_bindir]]
-endif
-
-deps = [
-  gtk_dep,
-  x11_dep,
-  dependency('egl'),
-  dependency('glesv2')
-]
-
-cflags = '-DPKGDATADIR="@0@"'.format(session_pkgdatadir)
-
-programs += [['gnome-session-check-accelerated-gles-helper', deps, cflags, session_libexecdir]]
-
-deps = [
-  glib_dep,
-  x11_dep,
-  dependency('gl'),
-  dependency('epoxy'),
-  dependency('xcomposite')
-]
-
-programs += [['gnome-session-check-accelerated-gl-helper', deps, cflags, session_libexecdir]]
-
-deps += [gtk_dep]
-
-cflags = '-DLIBEXECDIR="@0@"'.format(session_libexecdir)
-
-programs += [['gnome-session-check-accelerated', deps, cflags, session_libexecdir]]
-
 foreach program: programs
   executable(
     program[0],
-- 
GitLab

